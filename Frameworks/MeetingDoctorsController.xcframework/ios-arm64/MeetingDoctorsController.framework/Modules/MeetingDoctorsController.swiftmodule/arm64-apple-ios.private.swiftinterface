// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name MeetingDoctorsController
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AdSupport
import CoreLocation
import Foundation
import MeetingDoctorsCore
import MeetingDoctorsSchema
import Photos
import RxSwift
import Security
import Swift
import UIKit
import UserNotifications
import _Concurrency
import _StringProcessing
public class AuthenticationController {
  public init(_ installation: MeetingDoctorsController.InstallationController, repository: MeetingDoctorsController.RepositoryController, remote: MeetingDoctorsController.RemoteController, scheduler: RxSwift.ImmediateSchedulerType, auth: MeetingDoctorsController.CustomerAuthControllerProtocol)
  public func current(_ id: Swift.String) -> RxSwift.Observable<MeetingDoctorsController.AccountModel?>
  public func authenticate(_ id: Swift.String, notifier: Foundation.NotificationCenter = NotificationCenter.default) -> RxSwift.Observable<MeetingDoctorsController.AccountModel>
  public func updateUserInfo(_ account: MeetingDoctorsController.AccountModel, notifier: Foundation.NotificationCenter = NotificationCenter.default) -> RxSwift.Observable<MeetingDoctorsController.AccountModel>
  public func updateUserInfo(_ account: MeetingDoctorsController.AccountModel, notifier: Foundation.NotificationCenter = NotificationCenter.default, completion: @escaping (Swift.Result<MeetingDoctorsController.AccountModel?, Swift.Error>) -> Swift.Void)
  public func deauthenticate(notifier: Foundation.NotificationCenter = NotificationCenter.default) -> RxSwift.Observable<Swift.Void>
  public func authenticate(_ id: Swift.String, notifier: Foundation.NotificationCenter = NotificationCenter.default, completion: @escaping (Swift.Result<MeetingDoctorsController.AccountModel?, Swift.Error>) -> Swift.Void)
  @objc deinit
}
extension Foundation.NSNotification.Name {
  public struct MeetingDoctors {
    public struct Authentication {
      public static let Succeed: Foundation.Notification.Name
      public static let Failed: Foundation.Notification.Name
      public static let UserStatusChanged: Foundation.Notification.Name
      public static let UserBannedChanged: Foundation.Notification.Name
    }
    public struct CustomerAuthentication {
      public static let Succeed: Foundation.Notification.Name
    }
    public struct Deauthentication {
      public static let Succeed: Foundation.Notification.Name
      public static let Failed: Foundation.Notification.Name
    }
    public struct Socket {
      public static let StatusChanged: Foundation.Notification.Name
      public static let MessageReceived: Foundation.Notification.Name
      public static let MessageRead: Foundation.Notification.Name
      public static let WatchDogAct: Foundation.Notification.Name
    }
    public struct Style {
      public static let StyleChanged: Foundation.Notification.Name
    }
    public struct Message {
      public static let UnreadChanged: Foundation.Notification.Name
      public static let Sent: Foundation.Notification.Name
      public static let Read: Foundation.Notification.Name
    }
    public struct Messenger {
      public static let ChatEntered: Foundation.Notification.Name
      public static let ChatLeft: Foundation.Notification.Name
      public static let Update: Foundation.Notification.Name
    }
    public struct NPS {
      public static let NPSSendSucceed: Foundation.Notification.Name
    }
    public struct TermsAndConditions {
      public static let Declined: Foundation.Notification.Name
      public static let Accepted: Foundation.Notification.Name
    }
    public struct VideoCall {
      public static let videocall_requested: Foundation.Notification.Name
      public static let videocall_cancelled_user: Foundation.Notification.Name
      public static let videocall_professional_ready: Foundation.Notification.Name
      public static let videocall_cancelled_time_expired: Foundation.Notification.Name
      public static let videocall_user_joined: Foundation.Notification.Name
      public static let videocall_finished: Foundation.Notification.Name
      public static let videocall_cancelled_professional_busy: Foundation.Notification.Name
      public static let videocall_error_network: Foundation.Notification.Name
      public static let videocall_error_system: Foundation.Notification.Name
      public static let videocall_cancelled_user_requested_new: Foundation.Notification.Name
      public static let PickedUp: Foundation.Notification.Name
      public static let Finished: Foundation.Notification.Name
      public static let Cancelled: Foundation.Notification.Name
      public struct Process {
        public struct Searching {
          public static let Retry: Foundation.Notification.Name
        }
        public struct Canceled {
          public static let Error: Foundation.Notification.Name
          public static let Dismiss: Foundation.Notification.Name
          public static let Alert: Foundation.Notification.Name
          public static let Timeout: Foundation.Notification.Name
          public static let Reinit: Foundation.Notification.Name
        }
        public static let Init: Foundation.Notification.Name
        public static let Reinit: Foundation.Notification.Name
        public struct OneToOne {
          public static let SendMessage: Foundation.Notification.Name
        }
      }
    }
  }
  public struct MeetingDoctorsGroups {
    public static let Error: Foundation.Notification.Name
  }
  public struct MeetingDoctorsVideoCall {
    public static let Push: Foundation.Notification.Name
  }
}
extension Foundation.Notification {
  public struct Key {
    public struct MeetingDoctors {
      public static let Authentication: Swift.String
      public static let CustomerAuthentication: Swift.String
      public static let Deauthentication: Swift.String
      public struct Message {
        public static let UnreadChanged: Foundation.Notification.Name
        public static let Sent: Foundation.Notification.Name
        public static let Read: Foundation.Notification.Name
      }
      public struct Socket {
        public static let StatusChanged: Foundation.Notification.Name
        public static let MessageReceived: Foundation.Notification.Name
        public static let MessageRead: Foundation.Notification.Name
      }
      public static let Style: Swift.String
      public struct TermsAndConditions {
        public static let Declined: Foundation.Notification.Name
      }
    }
    public struct MeetingDoctorsGroups {
      public static let Error: Swift.String
    }
    public struct MeetingDoctorsVideoCall {
      public static let Push: Foundation.Notification.Name
    }
    public struct MeetingDoctorsProfessional {
      public struct Login {
        public static let View: Swift.String
      }
    }
    public struct VideoCall {
      public static let videoCallId: Swift.String
      public static let Item: Swift.String
      public struct Process {
        public static let Status: Foundation.Notification.Name
        public struct OneToOne {
          public static let SendMessage: Foundation.Notification.Name
        }
      }
    }
  }
}
public enum MedicalHistoryModel {
  case unknown
  case allergy(MeetingDoctorsController.AllergyModel?)
  case disease(MeetingDoctorsController.DiseaseModel?)
  case medication(MeetingDoctorsController.MedicationModel?)
  case imc(MeetingDoctorsController.IMCModel?)
  case videoCallReport(MeetingDoctorsController.VideoCallReportModel?)
  case derivation
  case myDocuments
  case prescription
}
extension MeetingDoctorsController.MedicalHistoryModel : Swift.Equatable {
  public static func == (lhs: MeetingDoctorsController.MedicalHistoryModel, rhs: MeetingDoctorsController.MedicalHistoryModel) -> Swift.Bool
}
extension MeetingDoctorsController.MedicalHistoryModel : MeetingDoctorsCore.Transmittable {
  public typealias SchemaObject = MeetingDoctorsSchema.MedicalHistoryGenericSchema
  public var schemaObject: MeetingDoctorsSchema.MedicalHistoryGenericSchema {
    get
  }
  public init(schemaObject _: MeetingDoctorsSchema.MedicalHistoryGenericSchema) throws
}
extension MeetingDoctorsController.SpecialityTypeModel {
  public static let count: Swift.Int
  public static let allCases: [MeetingDoctorsController.SpecialityTypeModel]
}
public protocol RepositoryController {
  var installation: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.InstallationModel> { get }
  var customerInstallation: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.CustomerInstallationModel> { get }
  var customerAuth: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.CustomerAuthModel> { get }
  var authentication: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.AccountModel> { get }
  var user: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.UserModel> { get }
  var inbox: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.InboxContactModel> { get }
  var conversations: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.ConversationModel> { get }
  var messages: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.MessageModel> { get }
  var schedules: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.ScheduleModel> { get }
  var allergy: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.AllergyModel> { get }
  var disease: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.DiseaseModel> { get }
  var medication: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.MedicationModel> { get }
  var imc: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.IMCModel> { get }
  var videoCallReport: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.VideoCallReportModel> { get }
  var derivationReport: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.DerivationReportModel> { get }
  var coverage: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.MedicalCoverageModel> { get }
  var speciality: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.MedicalSpecialityModel> { get }
  var professional: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.MedicalProfessionalModel> { get }
  func clear() -> RxSwift.Observable<Swift.Void>
}
public enum MessageDataModel {
  case text(Swift.String)
  case image(UIKit.UIImage?, url: Foundation.URL, thumb: Foundation.URL, width: Swift.Int, height: Swift.Int)
  case file(Foundation.Data?, name: Swift.String, url: Foundation.URL, size: Swift.Int)
  case note(Swift.String)
  case none
}
extension MeetingDoctorsController.MessageDataModel : MeetingDoctorsController.AutoEquatable {
}
extension MeetingDoctorsController.MessageDataModel {
  public var isImage: Swift.Bool {
    get
  }
  public var image: UIKit.UIImage? {
    get
  }
}
extension MeetingDoctorsController.MessageDataModel {
  public var attachmentURL: Foundation.URL? {
    get
  }
}
extension MeetingDoctorsController.MessageDataModel {
  public var name: Swift.String? {
    get
  }
}
extension MeetingDoctorsController.MessageDataModel {
  public var thumbnailURL: Foundation.URL? {
    get
  }
}
extension MeetingDoctorsController.MessageDataModel {
  public var size: CoreFoundation.CGSize? {
    get
  }
}
extension MeetingDoctorsController.MessageDataModel {
  public var isFile: Swift.Bool {
    get
  }
  public var count: Swift.Int? {
    get
  }
}
public protocol AutoLenses {
}
public enum MDVideocallStatusType : Swift.String, Swift.Codable, Swift.Equatable {
  case onHold
  case onGoing
  case cancelled
  case finished
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum MDVideocallStatus {
  case onHold(videocallId: Swift.String)
  case onGoing(participants: [MeetingDoctorsController.MDVideocallCommonDataResponse<MeetingDoctorsController.MDVideocallParticipantResponseModel>])
  case cancelled
  case finished
  case unknown
}
public enum MDVideocallPermission {
  case authorized(status: MeetingDoctorsController.MDVideocallStatus)
  case notDetermined(status: MeetingDoctorsController.MDVideocallStatus)
  case denied
  case unknown
}
public class InstallationController {
  public var current: RxSwift.Observable<MeetingDoctorsController.InstallationModel?> {
    get
  }
  public func current(completion: @escaping (Swift.Result<MeetingDoctorsController.InstallationModel?, Swift.Error>) -> Swift.Void)
  public var medicalHistoryActiveAndOptions: MeetingDoctorsController.MedicalHistoryActiveAndOptionsModel?
  public var setup: MeetingDoctorsSchema.SetupSchema?
  public init(_ id: MeetingDoctorsCore.NamedProperty<Foundation.UUID>, keystore: MeetingDoctorsCore.Keystore, repository: MeetingDoctorsController.RepositoryController, remote: MeetingDoctorsController.RemoteController, scheduler: RxSwift.ImmediateSchedulerType)
  public func fetch() -> RxSwift.Observable<MeetingDoctorsController.InstallationModel?>
  public func setup(in bundle: Foundation.Bundle) -> RxSwift.Observable<MeetingDoctorsSchema.SetupSchema>
  public func installation(with setup: MeetingDoctorsSchema.SetupSchema, in bundle: Foundation.Bundle) -> RxSwift.Observable<MeetingDoctorsController.InstallationModel>
  public func update(model: MeetingDoctorsController.InstallationModel, deviceToken: Swift.String) -> RxSwift.Observable<MeetingDoctorsController.InstallationModel>
  public func ping(in bundle: Foundation.Bundle) -> RxSwift.Completable
  public func fetch(completion: @escaping (Swift.Result<MeetingDoctorsController.InstallationModel?, Swift.Error>) -> Swift.Void)
  public func setup(in bundle: Foundation.Bundle, completion: @escaping (Swift.Result<MeetingDoctorsController.InstallationModel?, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public protocol EncryptionProviderAssembly {
  func resolve() -> MeetingDoctorsController.EncryptionProvider?
}
public class EncryptionProviderAssembler : MeetingDoctorsController.EncryptionProviderAssembly {
  public init(_ tag: Swift.String, configuration: MeetingDoctorsCore.BuildConfigurationType)
  public func resolve() -> MeetingDoctorsController.EncryptionProvider?
  @objc deinit
}
extension MeetingDoctorsController.EncryptionProviderAssembler : MeetingDoctorsCore.Assembler {
  public typealias Component = MeetingDoctorsController.EncryptionProvider
}
public enum MessengerRemoteNotificationModel {
  case message(Swift.String)
  case link(Foundation.URL)
  case rating
  case silent
  case unknown
}
extension MeetingDoctorsController.MessengerRemoteNotificationModel : Swift.Equatable {
  public static func == (a: MeetingDoctorsController.MessengerRemoteNotificationModel, b: MeetingDoctorsController.MessengerRemoteNotificationModel) -> Swift.Bool
}
extension MeetingDoctorsController.MessengerRemoteNotificationModel {
  public init(schema: MeetingDoctorsSchema.MessengerRemoteNotificationSchema)
}
public protocol ActionMessageAdapter {
  func requestMessage(_ request: MeetingDoctorsSchema.IncomingMessageRequest) -> RxSwift.Single<MeetingDoctorsSchema.ActionMessageSchema>
}
public enum MessageTypeModel : Swift.String {
  case text
  case image
  case file
  case note
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension MeetingDoctorsController.MessageTypeModel {
  public var schema: MeetingDoctorsSchema.MessageSchema.Kind {
    get
  }
}
public enum UserRegistrationStatusModel : Swift.String {
  case unknown
  case freemium
  case processing
  case formalized
  case canceled
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension MeetingDoctorsSchema.UserSchema.RegistrationStatus {
  public var model: MeetingDoctorsController.UserRegistrationStatusModel {
    get
  }
}
public struct DefaultEncryptionProvider : MeetingDoctorsController.EncryptionProvider {
}
public struct ProfessionalReportModel {
  public let id: Swift.Int?
  public let token: Swift.String?
  public let name: Swift.String?
  public let connected: Swift.Bool?
  public let hash: Swift.String?
  public init(id: Swift.Int?, token: Swift.String?, name: Swift.String?, connected: Swift.Bool?, hash: Swift.String?)
}
public protocol UserPreferencesType {
  var uuid: MeetingDoctorsCore.NamedProperty<Foundation.UUID> { get }
  var keystore: MeetingDoctorsCore.NamedProperty<MeetingDoctorsCore.Keystore> { get }
  var lastInboxUpdate: MeetingDoctorsCore.NamedProperty<Foundation.Date> { get }
  var isVideoCallStarted: MeetingDoctorsCore.NamedProperty<Swift.Bool> { get }
  var lastSocketUpdate: MeetingDoctorsCore.NamedProperty<Foundation.Date> { get }
  func clear(_ bundle: Foundation.Bundle)
}
public struct UserPreferences : MeetingDoctorsController.UserPreferencesType {
  public var uuid: MeetingDoctorsCore.NamedProperty<Foundation.UUID> {
    get
  }
  public var keystore: MeetingDoctorsCore.NamedProperty<MeetingDoctorsCore.Keystore> {
    get
  }
  public var lastInboxUpdate: MeetingDoctorsCore.NamedProperty<Foundation.Date> {
    get
  }
  public var isVideoCallStarted: MeetingDoctorsCore.NamedProperty<Swift.Bool> {
    get
  }
  public var lastSocketUpdate: MeetingDoctorsCore.NamedProperty<Foundation.Date> {
    get
  }
  public init(_ defaults: Foundation.UserDefaults)
  public func clear(_ bundle: Foundation.Bundle)
}
public protocol MessagesControllerType {
  func status(contact id: Swift.String) -> RxSwift.Observable<MeetingDoctorsController.ContactStatusModel?>
  func fetch(room id: Swift.Int) -> RxSwift.Observable<([MeetingDoctorsController.MessageModel], MeetingDoctorsController.Changeset?)>
  func join(channel: Swift.String) -> RxSwift.Observable<MeetingDoctorsSchema.SocketClientSchema.Input>
  func leave(room id: Swift.Int)
  func delete(room id: Swift.Int) -> RxSwift.Observable<Swift.Void>
  func send(message: MeetingDoctorsController.MessageModel) -> RxSwift.Observable<Swift.Void>
  func update(message: MeetingDoctorsController.MessageModel, status: MeetingDoctorsController.MessageStatusModel)
  func metadata(for image: UIKit.UIImage?, at url: Foundation.URL?, photoLibrary: Photos.PHPhotoLibrary) -> RxSwift.Observable<MeetingDoctorsController.MessageDataModel>
  func metadata(for data: Foundation.Data, at url: Foundation.URL) -> RxSwift.Observable<MeetingDoctorsController.MessageDataModel>
  func unreadMessages(account: MeetingDoctorsController.AccountModel) -> RxSwift.Observable<Swift.Int>
}
public class MessagesController : MeetingDoctorsController.MessagesControllerType {
  public init(_ repository: MeetingDoctorsController.RepositoryController, _ socket: MeetingDoctorsController.AnySocketControllerStream, _ scheduler: RxSwift.ImmediateSchedulerType)
  public func status(contact id: Swift.String) -> RxSwift.Observable<MeetingDoctorsController.ContactStatusModel?>
  public func fetch(room id: Swift.Int) -> RxSwift.Observable<([MeetingDoctorsController.MessageModel], MeetingDoctorsController.Changeset?)>
  public func join(channel: Swift.String) -> RxSwift.Observable<MeetingDoctorsSchema.SocketClientSchema.Input>
  public func leave(room id: Swift.Int)
  @discardableResult
  public func delete(room id: Swift.Int) -> RxSwift.Observable<Swift.Void>
  public func send(message: MeetingDoctorsController.MessageModel) -> RxSwift.Observable<Swift.Void>
  public func update(message: MeetingDoctorsController.MessageModel, status: MeetingDoctorsController.MessageStatusModel)
  public func metadata(for image: UIKit.UIImage?, at url: Foundation.URL?, photoLibrary: Photos.PHPhotoLibrary = PHPhotoLibrary.shared()) -> RxSwift.Observable<MeetingDoctorsController.MessageDataModel>
  public func metadata(for data: Foundation.Data, at url: Foundation.URL) -> RxSwift.Observable<MeetingDoctorsController.MessageDataModel>
  public func unreadMessages(account: MeetingDoctorsController.AccountModel) -> RxSwift.Observable<Swift.Int>
  @objc deinit
}
extension Foundation.Date {
  public var isToday: Swift.Bool {
    get
  }
}
public protocol CustomerAuthModelProtocol {
  var id: Swift.String { get }
  var accessToken: Swift.String { get }
  var tokenType: Swift.String { get }
  var user: MeetingDoctorsController.CustomerUserModel { get }
  var expiresIn: Swift.Double? { get }
  var updatedAt: Foundation.Date { get }
}
public struct CustomerAuthModel : Swift.Codable, MeetingDoctorsController.CustomerAuthModelProtocol {
  public let id: Swift.String
  public let accessToken: Swift.String
  public let tokenType: Swift.String
  public let user: MeetingDoctorsController.CustomerUserModel
  public let expiresIn: Swift.Double?
  public let updatedAt: Foundation.Date
  public init(id: Swift.String, accessToken: Swift.String, tokenType: Swift.String, user: MeetingDoctorsController.CustomerUserModel, expiresIn: Swift.Double?, updatedAt: Foundation.Date)
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension MeetingDoctorsController.CustomerAuthModel {
  public init(schema: MeetingDoctorsSchema.CustomerAuthSchema)
  public var expiresInSeconds: Swift.Double {
    get
  }
}
extension MeetingDoctorsController.CustomerAuthModel : MeetingDoctorsController.AutoLenses {
}
extension MeetingDoctorsController.CustomerAuthModel : Swift.Equatable {
  public static func == (a: MeetingDoctorsController.CustomerAuthModel, b: MeetingDoctorsController.CustomerAuthModel) -> Swift.Bool
}
public struct KeychainEncryptionProvider : MeetingDoctorsController.EncryptionProvider {
  public var key: Foundation.Data? {
    get
  }
  public init?(_ id: Swift.String)
  public init(_ tag: Foundation.Data)
  public func randomData(ofLength length: Swift.Int) -> Foundation.Data
}
public typealias MedicalQueryBuildable = MeetingDoctorsController.RemoteRequestBuildable & MeetingDoctorsController.StorePredicateBuildable
public protocol StorePredicateBuildable {
  func build() -> Foundation.NSPredicate
}
public protocol RemoteRequestBuildable {
  func build() -> MeetingDoctorsSchema.PaginableRequest
}
public class MedicalQueryBuilder {
  public enum Kind {
    case coverage
    case speciality
    case professional
    case address
    public static func == (a: MeetingDoctorsController.MedicalQueryBuilder.Kind, b: MeetingDoctorsController.MedicalQueryBuilder.Kind) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var keywords: Swift.String? {
    get
  }
  public var coverageId: Swift.String? {
    get
  }
  public var specialityId: Swift.String? {
    get
  }
  public var location: CoreLocation.CLLocationCoordinate2D? {
    get
  }
  public var page: MeetingDoctorsSchema.PageRequest? {
    get
  }
  public init(type: MeetingDoctorsController.MedicalQueryBuilder.Kind)
  public func with(keywords: Swift.String) -> Self
  public func with(coverageId: Swift.String) -> Self
  public func with(specialityId: Swift.String) -> Self
  public func with(location: CoreLocation.CLLocationCoordinate2D) -> Self
  public func with(page: MeetingDoctorsSchema.PageRequest) -> Self
  @objc deinit
}
extension MeetingDoctorsController.MedicalQueryBuilder : MeetingDoctorsController.StorePredicateBuildable {
  public func build() -> Foundation.NSPredicate
}
extension MeetingDoctorsController.MedicalQueryBuilder : MeetingDoctorsController.RemoteRequestBuildable {
  public func build() -> MeetingDoctorsSchema.PaginableRequest
}
public struct MDCompaniesArgumentGetResponse : Swift.Codable {
  public let id: Swift.String?
  public let apiKey: Swift.String?
  public let professional: Swift.String?
  public let customer: Swift.String?
  public let timezone: Swift.String?
  public let type: Swift.String?
  public let service: Swift.String?
  public let survey: MeetingDoctorsController.MDCompaniesArgumentSurveyGetResponse?
  public let createdAt: Foundation.Date?
  public let ratedAt: Foundation.Date?
  public let sentAt: Foundation.Date?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct MDCompaniesArgumentSurveyGetResponse : Swift.Codable {
  public let title: Swift.String
  public let body: Swift.String
  public let form: Swift.String
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public enum ControllerError : Swift.Error {
  public enum InstallationFailureReason {
    case nilValueFound
    case pingFailed
    public static func == (a: MeetingDoctorsController.ControllerError.InstallationFailureReason, b: MeetingDoctorsController.ControllerError.InstallationFailureReason) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum AuthenticationFailureReason {
    case invalidSessionToken(id: Swift.String)
  }
  public enum ImageLoaderFailureReason {
    case invalidURL(Foundation.URL)
  }
  public enum PhotoLibraryFailureReason {
    case placeholderForCreatedAssetFailed(Photos.PHAssetChangeRequest)
    case assetLocalIdentifierNotFound(Swift.String)
    case performChangesCompletion(Swift.Error)
  }
  public enum TransmittableFailureReason {
    case invalidTransmittableState
    case invalidTransmittableMapping
    public static func == (a: MeetingDoctorsController.ControllerError.TransmittableFailureReason, b: MeetingDoctorsController.ControllerError.TransmittableFailureReason) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  case installationFailed(reason: MeetingDoctorsController.ControllerError.InstallationFailureReason)
  case authenticationFailed(reason: MeetingDoctorsController.ControllerError.AuthenticationFailureReason)
  case imageLoaderFailed(reason: MeetingDoctorsController.ControllerError.ImageLoaderFailureReason)
  case photoLibraryFailed(reason: MeetingDoctorsController.ControllerError.PhotoLibraryFailureReason)
  case transmittableFailed(reason: MeetingDoctorsController.ControllerError.TransmittableFailureReason)
}
public protocol MedicalDirectoryDetailControllerType {
  func fetch(by id: Swift.String, completion: @escaping ((Swift.Result<(MeetingDoctorsController.MedicalProfessionalModel?, [MeetingDoctorsController.MedicalSpecialityModel]), Swift.Error>) -> Swift.Void))
}
public struct MedicalDirectoryDetailController : MeetingDoctorsController.MedicalDirectoryDetailControllerType {
  public init(_ professional: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.MedicalProfessionalModel>, speciality: MeetingDoctorsController.AnyRepository<MeetingDoctorsController.MedicalSpecialityModel>, scheduler: RxSwift.ImmediateSchedulerType, auth: MeetingDoctorsController.CustomerAuthControllerProtocol)
  public func fetch(by id: Swift.String, completion: @escaping ((Swift.Result<(MeetingDoctorsController.MedicalProfessionalModel?, [MeetingDoctorsController.MedicalSpecialityModel]), Swift.Error>) -> Swift.Void))
}
public protocol InstallationModelType {
  var id: Swift.String { get }
  var name: Swift.String { get }
  var uuid: Foundation.UUID { get }
  var system: MeetingDoctorsController.SystemModel { get }
  var systemVersion: Swift.String { get }
  var libVersion: Swift.String { get }
  var model: Swift.String { get }
  var deviceToken: Swift.String? { get }
  var locale: Foundation.Locale? { get }
  var timeZone: Foundation.TimeZone? { get }
  var referrer: MeetingDoctorsController.ReferrerModel? { get }
  var location: MeetingDoctorsController.LocationModel? { get }
  var createdAt: Foundation.Date { get }
  var updatedAt: Foundation.Date { get }
}
public struct InstallationModel : MeetingDoctorsController.InstallationModelType {
  public let id: Swift.String
  public let name: Swift.String
  public let uuid: Foundation.UUID
  public let system: MeetingDoctorsController.SystemModel
  public let systemVersion: Swift.String
  public let libVersion: Swift.String
  public let model: Swift.String
  public var deviceToken: Swift.String?
  public var locale: Foundation.Locale?
  public var timeZone: Foundation.TimeZone?
  public var referrer: MeetingDoctorsController.ReferrerModel?
  public var location: MeetingDoctorsController.LocationModel?
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public init(id: Swift.String, name: Swift.String, uuid: Foundation.UUID, system: MeetingDoctorsController.SystemModel, systemVersion: Swift.String, libVersion: Swift.String, model: Swift.String, deviceToken: Swift.String?, locale: Foundation.Locale?, timeZone: Foundation.TimeZone?, referrer: MeetingDoctorsController.ReferrerModel?, location: MeetingDoctorsController.LocationModel?, createdAt: Foundation.Date, updatedAt: Foundation.Date)
}
extension MeetingDoctorsController.InstallationModel {
  public init(_ keystore: MeetingDoctorsCore.Keystore, uuid: Foundation.UUID, bundle: Foundation.Bundle, device: UIKit.UIDevice = UIDevice.current, locale: Foundation.Locale = Locale.autoupdatingCurrent, timeZone: Foundation.TimeZone = TimeZone.current, referrer: MeetingDoctorsController.ReferrerModel? = nil, location: MeetingDoctorsController.LocationModel? = nil, date: Foundation.Date = Date())
}
extension MeetingDoctorsController.InstallationModel : MeetingDoctorsController.AutoLenses {
}
public protocol MedicalDirectoryListControllerType {
  associatedtype ElementModel : MeetingDoctorsCore.Transmittable
  func fetch(query: MeetingDoctorsController.MedicalQueryBuilder, completion: @escaping (Swift.Result<[Self.ElementModel], Swift.Error>) -> Swift.Void)
  func get(query: MeetingDoctorsController.MedicalQueryBuilder, completion: @escaping (Swift.Result<[Self.ElementModel], Swift.Error>) -> Swift.Void)
}
extension MeetingDoctorsController.MedicalDirectoryListControllerType {
  public func get(query _: MeetingDoctorsController.MedicalQueryBuilder, completion _: @escaping (Swift.Result<[Self.ElementModel], Swift.Error>) -> Swift.Void)
  public func fetch(query _: MeetingDoctorsController.MedicalQueryBuilder, completion _: @escaping (Swift.Result<[Self.ElementModel], Swift.Error>) -> Swift.Void)
}
public struct MedicalDirectoryListController<Model> : MeetingDoctorsController.MedicalDirectoryListControllerType where Model : MeetingDoctorsCore.Transmittable, Model.SchemaObject : MeetingDoctorsSchema.MedicalDirectorySchema {
  public typealias ElementModel = Model
  public init(_ repository: MeetingDoctorsController.AnyRepository<Model>, _ adapter: MeetingDoctorsController.AnyMedicalDirectoryAdapter<Model.SchemaObject>, scheduler: RxSwift.ImmediateSchedulerType, auth: MeetingDoctorsController.CustomerAuthControllerProtocol)
  public func fetch(query: MeetingDoctorsController.MedicalQueryBuilder, completion: @escaping (Swift.Result<[Model], Swift.Error>) -> Swift.Void)
}
extension MeetingDoctorsController.MedicalDirectoryListController where Model == MeetingDoctorsController.MedicalCoverageModel {
  public func get(query: MeetingDoctorsController.MedicalQueryBuilder, completion: @escaping (Swift.Result<[Model], Swift.Error>) -> Swift.Void)
}
extension MeetingDoctorsController.MedicalDirectoryListController where Model == MeetingDoctorsController.MedicalSpecialityModel {
  public func get(query: MeetingDoctorsController.MedicalQueryBuilder, completion: @escaping (Swift.Result<[Model], Swift.Error>) -> Swift.Void)
}
extension MeetingDoctorsController.MedicalDirectoryListController where Model == MeetingDoctorsController.MedicalProfessionalModel {
  public func fetch(query: MeetingDoctorsController.MedicalQueryBuilder, completion: @escaping (Swift.Result<[Model], Swift.Error>) -> Swift.Void)
  public func get(query: MeetingDoctorsController.MedicalQueryBuilder, completion: @escaping (Swift.Result<[Model], Swift.Error>) -> Swift.Void)
}
extension MeetingDoctorsController.MedicalDirectoryListController where Model == MeetingDoctorsController.MedicalAddressModel {
  #warning("SimpleRepository applies on non-persistable models")
  public init(_ adapter: MeetingDoctorsController.AnyMedicalDirectoryAdapter<MeetingDoctorsSchema.MedicalAddressSchema>, auth: MeetingDoctorsController.CustomerAuthControllerProtocol)
  public func get(query: MeetingDoctorsController.MedicalQueryBuilder, completion: @escaping (Swift.Result<[Model], Swift.Error>) -> Swift.Void)
}
public protocol ProfessionalListAdapter {
  func requestProfessionalDetail(_ professionalHash: Swift.String) -> RxSwift.Single<MeetingDoctorsSchema.ContactSchema>
}
public protocol RemoteControllerAssembly {
  func resolve() -> MeetingDoctorsController.RemoteController?
}
extension Foundation.Date {
  public var isYesterday: Swift.Bool {
    get
  }
}
public class MDVideocallJoinRequestModel : Swift.Codable {
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public protocol CustomerNotificationsControllerProtocol {
  func register(_ token: Swift.String) -> RxSwift.Observable<MeetingDoctorsController.CustomerInstallationModel>
  func unregister() -> RxSwift.Observable<MeetingDoctorsController.CustomerInstallationModel>
}
public class CustomerNotificationsController : MeetingDoctorsController.CustomerNotificationsControllerProtocol {
  public init(installation: MeetingDoctorsController.CustomerInstallationControllerProtocol, auth: MeetingDoctorsController.CustomerAuthControllerProtocol, remote: MeetingDoctorsController.RemoteController, scheduler: RxSwift.ImmediateSchedulerType)
  public func register(_ token: Swift.String) -> RxSwift.Observable<MeetingDoctorsController.CustomerInstallationModel>
  public func unregister() -> RxSwift.Observable<MeetingDoctorsController.CustomerInstallationModel>
  @objc deinit
}
public protocol VideoCallConsultationModelProtocol {
  var videoCallId: Swift.Int? { get }
  var tokenId: Swift.String? { get }
  var sessionId: Swift.String? { get }
}
public struct VideoCallConsultationModel : MeetingDoctorsController.VideoCallConsultationModelProtocol {
  public let videoCallId: Swift.Int?
  public let tokenId: Swift.String?
  public let sessionId: Swift.String?
  public init(videoCallId: Swift.Int?, tokenId: Swift.String?, sessionId: Swift.String?)
}
extension MeetingDoctorsController.VideoCallConsultationModel {
  public init(schema: MeetingDoctorsSchema.VideoCallConsultationSchema)
}
extension MeetingDoctorsController.VideoCallConsultationModel : MeetingDoctorsController.AutoLenses {
}
extension MeetingDoctorsController.VideoCallConsultationModel : Swift.Equatable {
  public static func == (a: MeetingDoctorsController.VideoCallConsultationModel, b: MeetingDoctorsController.VideoCallConsultationModel) -> Swift.Bool
}
public protocol CustomerAuthAdapter {
  func login(_ request: MeetingDoctorsSchema.CustomerLoginRequest) -> RxSwift.Single<MeetingDoctorsSchema.CustomerAuthSchema>
  func login(_ request: MeetingDoctorsSchema.CustomerLoginRequest, completion: @escaping (Swift.Result<MeetingDoctorsSchema.CustomerAuthSchema, Swift.Error>) -> Swift.Void)
}
public protocol NotificationAdapter {
  func unread(_ request: MeetingDoctorsSchema.MessageCountRequest) -> RxSwift.Single<MeetingDoctorsSchema.CountSchema>
}
public protocol MedicalHistoryAdapter {
  associatedtype SchemaType : MeetingDoctorsSchema.MedicalHistorySchema
  func fetch(by id: Swift.String) -> RxSwift.Single<Self.SchemaType?>
  func fetch() -> RxSwift.Single<[Self.SchemaType]>
  func save(entity: Self.SchemaType, update: Swift.Bool) -> RxSwift.Single<Self.SchemaType>
  func delete(entity: Self.SchemaType) -> RxSwift.Completable
}
public protocol IdentifiableAdapter {
  associatedtype SchemaType : MeetingDoctorsSchema.IdentifiableSchema
  func fetch(by id: Swift.String) -> RxSwift.Single<Self.SchemaType?>
  func fetch() -> RxSwift.Single<[Self.SchemaType]>
  func save(entity: Self.SchemaType, update: Swift.Bool) -> RxSwift.Single<Self.SchemaType>
  func delete(entity: Self.SchemaType) -> RxSwift.Completable
}
public enum MDVideocallParticipantType : Swift.String, Swift.Codable {
  case moderator
  case participant
  public func callAsFunction() -> Swift.String
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public class ErrorBodyModel : Swift.Codable {
  final public let code: Swift.Int
  final public let name: Swift.String
  final public let message: Swift.String
  final public let scope: Swift.String
  public init(code: Swift.Int = 0, name: Swift.String = "", message: Swift.String = "", scope: Swift.String = "")
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public enum ContactRoleModel : Swift.String {
  case unknown
  case commercial
  case administrative
  case doctor
  case support
  case free
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ConnectionStatusModel : Swift.Int {
  case notConnected
  case disconnected
  case connecting
  case connected
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension MeetingDoctorsController.ConnectionStatusModel {
  public var isConnected: Swift.Bool {
    get
  }
}
extension MeetingDoctorsController.ConnectionStatusModel : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol AutoEquatable {
}
public protocol CustomerAuthControllerProtocol {
  func current() -> RxSwift.Observable<MeetingDoctorsController.CustomerAuthModel?>
  func login(_ id: Swift.String) -> RxSwift.Observable<MeetingDoctorsController.CustomerAuthModel>
  func refresh() -> RxSwift.Observable<MeetingDoctorsController.CustomerAuthModel>
  func current(completion: @escaping (Swift.Result<MeetingDoctorsController.CustomerAuthModel?, Swift.Error>) -> Swift.Void)
  func login(_ id: Swift.String, completion: @escaping (Swift.Result<MeetingDoctorsController.CustomerAuthModel?, Swift.Error>) -> Swift.Void)
  func refresh(completion: @escaping (Swift.Result<MeetingDoctorsController.CustomerAuthModel?, Swift.Error>) -> Swift.Void)
}
public class CustomerAuthController : MeetingDoctorsController.CustomerAuthControllerProtocol {
  public init(installation: MeetingDoctorsController.CustomerInstallationControllerProtocol, repository: MeetingDoctorsController.RepositoryController, remote: MeetingDoctorsController.RemoteController, scheduler: RxSwift.ImmediateSchedulerType)
  public func current() -> RxSwift.Observable<MeetingDoctorsController.CustomerAuthModel?>
  public func login(_ id: Swift.String) -> RxSwift.Observable<MeetingDoctorsController.CustomerAuthModel>
  public func refresh() -> RxSwift.Observable<MeetingDoctorsController.CustomerAuthModel>
  public func current(completion: @escaping (Swift.Result<MeetingDoctorsController.CustomerAuthModel?, Swift.Error>) -> Swift.Void)
  public func login(_ id: Swift.String, completion: @escaping (Swift.Result<MeetingDoctorsController.CustomerAuthModel?, Swift.Error>) -> Swift.Void)
  public func refresh(completion: @escaping (Swift.Result<MeetingDoctorsController.CustomerAuthModel?, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public protocol MedicalHistoryListControllerType {
  associatedtype ElementModel : MeetingDoctorsCore.Transmittable
  func fetch(patient hash: Swift.String) -> RxSwift.Observable<([Self.ElementModel], MeetingDoctorsController.Changeset?)>
}
public class MedicalHistoryMainController : MeetingDoctorsController.MedicalHistoryListControllerType {
  public typealias ElementModel = MeetingDoctorsController.MedicalHistoryModel
  public init(_ hasVideoCall: Swift.Bool, allowedOptions: [MeetingDoctorsController.MedicalHistoryModel])
  public func fetch(patient _: Swift.String) -> RxSwift.Observable<([MeetingDoctorsController.MedicalHistoryModel], MeetingDoctorsController.Changeset?)>
  @objc deinit
}
public class MedicalHistoryListController<Model> : MeetingDoctorsController.MedicalHistoryListControllerType where Model : MeetingDoctorsCore.Transmittable, Model.SchemaObject : MeetingDoctorsSchema.MedicalHistorySchema {
  public init(_ repository: MeetingDoctorsController.AnyRepository<Model>, _ adapter: MeetingDoctorsController.AnyMedicalHistoryAdapter<Model.SchemaObject>, scheduler: RxSwift.ImmediateSchedulerType, auth: MeetingDoctorsController.CustomerAuthControllerProtocol)
  public func fetch(patient hash: Swift.String) -> RxSwift.Observable<([Model], MeetingDoctorsController.Changeset?)>
  public typealias ElementModel = Model
  @objc deinit
}
public class MedicalHistoryIdentifiableListController<Model> : MeetingDoctorsController.MedicalHistoryListControllerType where Model : MeetingDoctorsCore.Transmittable, Model.SchemaObject : MeetingDoctorsSchema.IdentifiableSchema {
  public init(_ repository: MeetingDoctorsController.AnyRepository<Model>, _ adapter: MeetingDoctorsController.AnyIdentifiableAdapter<Model.SchemaObject>, scheduler: RxSwift.ImmediateSchedulerType, auth: MeetingDoctorsController.CustomerAuthControllerProtocol)
  public func fetch(patient hash: Swift.String) -> RxSwift.Observable<([Model], MeetingDoctorsController.Changeset?)>
  public typealias ElementModel = Model
  @objc deinit
}
public struct SimpleRepository<E> : MeetingDoctorsController.Repository {
  public init()
  public func fetch(by _: Swift.String) -> RxSwift.Observable<E?>
  public func fetch() -> RxSwift.Observable<([E], MeetingDoctorsController.Changeset?)>
  public func query(with _: Foundation.NSPredicate, sorted _: [Foundation.NSSortDescriptor], offset _: Swift.Int, limit _: Swift.Int) -> RxSwift.Observable<([E], MeetingDoctorsController.Changeset?)>
  public func save(entity _: E, update _: Swift.Bool) -> RxSwift.Observable<Swift.Void>
  public func save<S>(collection _: S, update _: Swift.Bool, clear _: Swift.Bool) -> RxSwift.Observable<Swift.Void> where E == S.Element, S : Swift.Sequence
  public func update(properties _: [MeetingDoctorsController.AttributeValueType]) -> RxSwift.Observable<Swift.Void>
  public func delete(entity _: E) -> RxSwift.Observable<Swift.Void>
  public func delete<S>(collection _: S) -> RxSwift.Observable<Swift.Void> where E == S.Element, S : Swift.Sequence
  public func delete(with _: Foundation.NSPredicate) -> RxSwift.Observable<Swift.Void>
  public func clear(cascading _: Swift.Bool) -> RxSwift.Observable<Swift.Void>
  public func fetch(by _: Swift.String, completion: @escaping (Swift.Result<E?, Swift.Error>) -> Swift.Void)
  public func fetch(completion: @escaping (Swift.Result<[E], Swift.Error>) -> Swift.Void)
  public func query(with _: Foundation.NSPredicate, sorted _: [Foundation.NSSortDescriptor], offset _: Swift.Int, limit _: Swift.Int, completion: @escaping (Swift.Result<[E], Swift.Error>) -> Swift.Void)
  public func save(entity _: E, update _: Swift.Bool, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func save<S>(collection _: S, update _: Swift.Bool, clear _: Swift.Bool, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) where E == S.Element, S : Swift.Sequence
  public func update(properties _: [MeetingDoctorsController.AttributeValueType], completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func delete(entity _: E, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func delete<S>(collection _: S, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) where E == S.Element, S : Swift.Sequence
  public func delete(with _: Foundation.NSPredicate, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func clear(cascading _: Swift.Bool, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public typealias EntityType = E
}
public protocol VideoCallStatusModelProtocol {
  var professional: MeetingDoctorsController.VideoCallProfessionalModel? { get }
  var type: MeetingDoctorsSchema.VideoCallRemoteNotificationType { get }
}
public struct VideoCallStatusModel : MeetingDoctorsController.VideoCallStatusModelProtocol {
  public let professional: MeetingDoctorsController.VideoCallProfessionalModel?
  public let type: MeetingDoctorsSchema.VideoCallRemoteNotificationType
  public init(professional: MeetingDoctorsController.VideoCallProfessionalModel?, type: MeetingDoctorsSchema.VideoCallRemoteNotificationType = .unknown)
}
extension MeetingDoctorsController.VideoCallStatusModel {
  public init(schema: MeetingDoctorsSchema.VideoCallStatusSchema)
}
extension MeetingDoctorsController.VideoCallStatusModel : Swift.Equatable {
  public static func == (a: MeetingDoctorsController.VideoCallStatusModel, b: MeetingDoctorsController.VideoCallStatusModel) -> Swift.Bool
}
public protocol MedicalHistoryDetailControllerType {
  associatedtype ElementModel : MeetingDoctorsCore.Transmittable
  func fetch(by id: Swift.String) -> RxSwift.Observable<Self.ElementModel?>
  func save(_ element: Self.ElementModel, update: Swift.Bool) -> RxSwift.Observable<Self.ElementModel>
  func delete(_ element: Self.ElementModel) -> RxSwift.Observable<Swift.Void>
}
public class MedicalHistoryDetailController<Model> : MeetingDoctorsController.MedicalHistoryDetailControllerType where Model : MeetingDoctorsCore.Transmittable, Model.SchemaObject : MeetingDoctorsSchema.MedicalHistorySchema {
  public init(_ repository: MeetingDoctorsController.AnyRepository<Model>, _ adapter: MeetingDoctorsController.AnyMedicalHistoryAdapter<Model.SchemaObject>, scheduler: RxSwift.ImmediateSchedulerType, auth: MeetingDoctorsController.CustomerAuthControllerProtocol)
  public func fetch(by id: Swift.String) -> RxSwift.Observable<Model?>
  public func save(_ element: Model, update: Swift.Bool) -> RxSwift.Observable<Model>
  public func delete(_ element: Model) -> RxSwift.Observable<Swift.Void>
  public typealias ElementModel = Model
  @objc deinit
}
public class MedicalHistoryDetailIdentifiableController<Model> : MeetingDoctorsController.MedicalHistoryDetailControllerType where Model : MeetingDoctorsCore.Transmittable, Model.SchemaObject : MeetingDoctorsSchema.IdentifiableSchema {
  public init(_ repository: MeetingDoctorsController.AnyRepository<Model>, _ adapter: MeetingDoctorsController.AnyIdentifiableAdapter<Model.SchemaObject>, scheduler: RxSwift.ImmediateSchedulerType, auth: MeetingDoctorsController.CustomerAuthControllerProtocol)
  public func fetch(by id: Swift.String) -> RxSwift.Observable<Model?>
  public func save(_ element: Model, update: Swift.Bool) -> RxSwift.Observable<Model>
  public func delete(_ element: Model) -> RxSwift.Observable<Swift.Void>
  public typealias ElementModel = Model
  @objc deinit
}
infix operator *~ : MultiplicationPrecedence
infix operator |> : AdditionPrecedence
public struct Lens<Whole, Part> {
  public let get: (Whole) -> Part
  public let set: (Part, Whole) -> Whole
}
public func * <A, B, C>(lhs: MeetingDoctorsController.Lens<A, B>, rhs: MeetingDoctorsController.Lens<B, C>) -> MeetingDoctorsController.Lens<A, C>
public func *~ <A, B>(lhs: MeetingDoctorsController.Lens<A, B>, rhs: B) -> (A) -> A
public func |> <A, B>(x: A, f: (A) -> B) -> B
public func |> <A, B, C>(f: @escaping (A) -> B, g: @escaping (B) -> C) -> (A) -> C
extension MeetingDoctorsController.AccountModel {
  public static let idLens: MeetingDoctorsController.Lens<MeetingDoctorsController.AccountModel, Swift.String>
  public static let tokenLens: MeetingDoctorsController.Lens<MeetingDoctorsController.AccountModel, Swift.String>
  public static let userLens: MeetingDoctorsController.Lens<MeetingDoctorsController.AccountModel, MeetingDoctorsController.UserModel>
  public static let installationLens: MeetingDoctorsController.Lens<MeetingDoctorsController.AccountModel, MeetingDoctorsController.InstallationModel>
}
extension MeetingDoctorsController.AllergyModel {
  public static let idLens: MeetingDoctorsController.Lens<MeetingDoctorsController.AllergyModel, Swift.String>
  public static let nameLens: MeetingDoctorsController.Lens<MeetingDoctorsController.AllergyModel, Swift.String>
  public static let severityLens: MeetingDoctorsController.Lens<MeetingDoctorsController.AllergyModel, Swift.Int>
  public static let detailsLens: MeetingDoctorsController.Lens<MeetingDoctorsController.AllergyModel, Swift.String>
  public static let patientHashLens: MeetingDoctorsController.Lens<MeetingDoctorsController.AllergyModel, Swift.String>
}
extension MeetingDoctorsController.CustomerAuthModel {
  public static let idLens: MeetingDoctorsController.Lens<MeetingDoctorsController.CustomerAuthModel, Swift.String>
  public static let accessTokenLens: MeetingDoctorsController.Lens<MeetingDoctorsController.CustomerAuthModel, Swift.String>
  public static let tokenTypeLens: MeetingDoctorsController.Lens<MeetingDoctorsController.CustomerAuthModel, Swift.String>
  public static let userLens: MeetingDoctorsController.Lens<MeetingDoctorsController.CustomerAuthModel, MeetingDoctorsController.CustomerUserModel>
  public static let expiresInLens: MeetingDoctorsController.Lens<MeetingDoctorsController.CustomerAuthModel, Swift.Double?>
  public static let updatedAtLens: MeetingDoctorsController.Lens<MeetingDoctorsController.CustomerAuthModel, Foundation.Date>
}
extension MeetingDoctorsController.CustomerInstallationModel {
  public static let idLens: MeetingDoctorsController.Lens<MeetingDoctorsController.CustomerInstallationModel, Swift.String>
  public static let installationGuidLens: MeetingDoctorsController.Lens<MeetingDoctorsController.CustomerInstallationModel, Swift.String>
  public static let pushTokenLens: MeetingDoctorsController.Lens<MeetingDoctorsController.CustomerInstallationModel, Swift.String?>
}
extension MeetingDoctorsController.DiseaseModel {
  public static let idLens: MeetingDoctorsController.Lens<MeetingDoctorsController.DiseaseModel, Swift.String>
  public static let nameLens: MeetingDoctorsController.Lens<MeetingDoctorsController.DiseaseModel, Swift.String>
  public static let detailsLens: MeetingDoctorsController.Lens<MeetingDoctorsController.DiseaseModel, Swift.String?>
  public static let diagnosisLens: MeetingDoctorsController.Lens<MeetingDoctorsController.DiseaseModel, Foundation.Date?>
  public static let resolutionLens: MeetingDoctorsController.Lens<MeetingDoctorsController.DiseaseModel, Foundation.Date?>
  public static let patientHashLens: MeetingDoctorsController.Lens<MeetingDoctorsController.DiseaseModel, Swift.String>
}
extension MeetingDoctorsController.IMCModel {
  public static let idLens: MeetingDoctorsController.Lens<MeetingDoctorsController.IMCModel, Swift.String>
  public static let weightLens: MeetingDoctorsController.Lens<MeetingDoctorsController.IMCModel, Swift.Int?>
  public static let heightLens: MeetingDoctorsController.Lens<MeetingDoctorsController.IMCModel, Swift.Int?>
  public static let valueLens: MeetingDoctorsController.Lens<MeetingDoctorsController.IMCModel, Swift.Float?>
  public static let patientHashLens: MeetingDoctorsController.Lens<MeetingDoctorsController.IMCModel, Swift.String>
  public static let updatedAtLens: MeetingDoctorsController.Lens<MeetingDoctorsController.IMCModel, Foundation.Date?>
  public static let createdAtLens: MeetingDoctorsController.Lens<MeetingDoctorsController.IMCModel, Foundation.Date?>
}
extension MeetingDoctorsController.InboxContactModel {
  public static let idLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Swift.String>
  public static let channelLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Swift.String>
  public static let nameLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Swift.String>
  public static let avatarURLLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Foundation.URL>
  public static let overviewLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Swift.String>
  public static let specialityLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Swift.String>
  public static let specialityCodeLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Swift.String>
  public static let specialityTypeLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, MeetingDoctorsController.SpecialityTypeModel>
  public static let roleLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, MeetingDoctorsController.ContactRoleModel>
  public static let statusLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, MeetingDoctorsController.ContactStatusModel>
  public static let unreadLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, [MeetingDoctorsController.MessageModel]>
  public static let lastMessageTimestampLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Foundation.TimeInterval?>
  public static let pendingLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Swift.Int>
  public static let timezoneLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Foundation.TimeZone>
  public static let timeZoneOffsetLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Swift.Int>
  public static let nextOnlineAtLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Foundation.Date?>
  public static let nextOfflineAtLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Foundation.Date?>
  public static let onHolidaysLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Swift.Bool>
  public static let schedulesLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, [MeetingDoctorsController.ScheduleModel]>
  public static let updatedAtLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Foundation.Date>
  public static let saturatedLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Swift.String>
  public static let collegiateNumberLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Swift.String>
  public static let conversationIdLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Swift.String?>
  public static let isVcAvailableLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Swift.Bool?>
  public static let isAccessibleLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InboxContactModel, Swift.Bool>
}
extension MeetingDoctorsController.InstallationModel {
  public static let idLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InstallationModel, Swift.String>
  public static let nameLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InstallationModel, Swift.String>
  public static let uuidLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InstallationModel, Foundation.UUID>
  public static let systemLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InstallationModel, MeetingDoctorsController.SystemModel>
  public static let systemVersionLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InstallationModel, Swift.String>
  public static let libVersionLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InstallationModel, Swift.String>
  public static let modelLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InstallationModel, Swift.String>
  public static let deviceTokenLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InstallationModel, Swift.String?>
  public static let localeLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InstallationModel, Foundation.Locale?>
  public static let timeZoneLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InstallationModel, Foundation.TimeZone?>
  public static let referrerLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InstallationModel, MeetingDoctorsController.ReferrerModel?>
  public static let locationLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InstallationModel, MeetingDoctorsController.LocationModel?>
  public static let createdAtLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InstallationModel, Foundation.Date>
  public static let updatedAtLens: MeetingDoctorsController.Lens<MeetingDoctorsController.InstallationModel, Foundation.Date>
}
extension MeetingDoctorsController.MedicalSpecialityModel {
  public static let idLens: MeetingDoctorsController.Lens<MeetingDoctorsController.MedicalSpecialityModel, Swift.String>
  public static let nameLens: MeetingDoctorsController.Lens<MeetingDoctorsController.MedicalSpecialityModel, Swift.String>
  public static let coverageIdLens: MeetingDoctorsController.Lens<MeetingDoctorsController.MedicalSpecialityModel, Swift.String?>
  public static let detailsLens: MeetingDoctorsController.Lens<MeetingDoctorsController.MedicalSpecialityModel, Swift.String?>
}
extension MeetingDoctorsController.MedicationModel {
  public static let idLens: MeetingDoctorsController.Lens<MeetingDoctorsController.MedicationModel, Swift.String>
  public static let nameLens: MeetingDoctorsController.Lens<MeetingDoctorsController.MedicationModel, Swift.String>
  public static let posologyLens: MeetingDoctorsController.Lens<MeetingDoctorsController.MedicationModel, Swift.String?>
  public static let detailsLens: MeetingDoctorsController.Lens<MeetingDoctorsController.MedicationModel, Swift.String?>
  public static let patientHashLens: MeetingDoctorsController.Lens<MeetingDoctorsController.MedicationModel, Swift.String>
}
extension MeetingDoctorsController.MessageModel {
  public static let idLens: MeetingDoctorsController.Lens<MeetingDoctorsController.MessageModel, Swift.String>
  public static let roomLens: MeetingDoctorsController.Lens<MeetingDoctorsController.MessageModel, Swift.String>
  public static let senderLens: MeetingDoctorsController.Lens<MeetingDoctorsController.MessageModel, Swift.String>
  public static let metadataLens: MeetingDoctorsController.Lens<MeetingDoctorsController.MessageModel, MeetingDoctorsController.MessageDataModel>
  public static let statusLens: MeetingDoctorsController.Lens<MeetingDoctorsController.MessageModel, MeetingDoctorsController.MessageStatusModel>
  public static let timestampLens: MeetingDoctorsController.Lens<MeetingDoctorsController.MessageModel, Foundation.TimeInterval>
}
extension MeetingDoctorsController.VideoCallConsultationModel {
  public static let videoCallIdLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallConsultationModel, Swift.Int?>
  public static let tokenIdLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallConsultationModel, Swift.String?>
  public static let sessionIdLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallConsultationModel, Swift.String?>
}
extension MeetingDoctorsController.VideoCallModel {
  public static let idLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallModel, Swift.Int>
  public static let workflowLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallModel, Swift.String>
  public static let roomIdLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallModel, Swift.Int?>
  public static let professionalHashLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallModel, Swift.String?>
}
extension MeetingDoctorsController.VideoCallProfessionalModel {
  public static let nameLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallProfessionalModel, Swift.String?>
  public static let avatarLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallProfessionalModel, Swift.String?>
  public static let detailLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallProfessionalModel, Swift.String?>
}
extension MeetingDoctorsController.VideoCallReportModel {
  public static let idLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallReportModel, Swift.Int>
  public static let pdfUrlLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallReportModel, Swift.String?>
  public static let ownerLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallReportModel, MeetingDoctorsController.VideoCallUserModel?>
  public static let makerLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallReportModel, MeetingDoctorsController.VideoCallUserModel?>
  public static let createdAtLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallReportModel, Foundation.Date?>
  public static let updatedAtLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallReportModel, Foundation.Date?>
}
extension MeetingDoctorsController.VideoCallUserModel {
  public static let hashLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallUserModel, Swift.String>
  public static let nameLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallUserModel, Swift.String?>
  public static let avatarLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallUserModel, Swift.String?>
  public static let descriptionLens: MeetingDoctorsController.Lens<MeetingDoctorsController.VideoCallUserModel, Swift.String?>
}
public enum DerivationType : Swift.String {
  case interconsultation
  case diagnosticProcedures
  case therapeuticProcedures
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct DerivationReportModel {
  public let id: Swift.Int?
  public let type: MeetingDoctorsController.DerivationType?
  public let payload: Swift.String?
  public let filename: Swift.String?
  public let url: Swift.String?
  public let company: MeetingDoctorsController.CompanyReportModel?
  public let professional: MeetingDoctorsController.ProfessionalReportModel?
  public let createdAt: Swift.String?
  public let customerHash: Swift.String?
  public let friendlyName: Swift.String?
  public init(id: Swift.Int?, type: Swift.String?, payload: Swift.String?, filename: Swift.String?, url: Swift.String?, company: MeetingDoctorsController.CompanyReportModel?, professional: MeetingDoctorsController.ProfessionalReportModel?, createdAt: Swift.String?, customerHash: Swift.String?, friendlyName: Swift.String?)
  public init(schemaObject: MeetingDoctorsSchema.DerivationReportSchema) throws
}
public protocol VideoCallRepositoryProtocol : AnyObject {
  func call(completion: @escaping (MeetingDoctorsController.VideoCallModel?) -> Swift.Void)
  func cancel(by id: Swift.Int, with completion: @escaping (MeetingDoctorsController.VideoCallModel?) -> Swift.Void)
  func pickUp(by id: Swift.Int, with completion: @escaping (MeetingDoctorsController.VideoCallModel) -> Swift.Void)
  func hangUp(by id: Swift.Int, with completion: @escaping (MeetingDoctorsController.VideoCallModel) -> Swift.Void)
  func videoCallStatus(with completion: @escaping (MeetingDoctorsController.VideoCallStatusModel?) -> Swift.Void)
}
public class VideoCallRepository : MeetingDoctorsController.VideoCallRepositoryProtocol {
  public init(remote: MeetingDoctorsController.RemoteController, auth: MeetingDoctorsController.CustomerAuthControllerProtocol)
  public func call(completion: @escaping (MeetingDoctorsController.VideoCallModel?) -> Swift.Void)
  public func cancel(by id: Swift.Int, with completion: @escaping (MeetingDoctorsController.VideoCallModel?) -> Swift.Void)
  public func pickUp(by id: Swift.Int, with completion: @escaping (MeetingDoctorsController.VideoCallModel) -> Swift.Void)
  public func hangUp(by id: Swift.Int, with completion: @escaping (MeetingDoctorsController.VideoCallModel) -> Swift.Void)
  public func videoCallStatus(with completion: @escaping (MeetingDoctorsController.VideoCallStatusModel?) -> Swift.Void)
  @objc deinit
}
public protocol VideoCall1to1Adapter {
  func requestVideoCall1to1(_ professionalHash: Swift.String) -> RxSwift.Single<MeetingDoctorsSchema.VideoCall1to1Schema>
  func cancel(by id: Swift.Int) -> RxSwift.Single<MeetingDoctorsSchema.VideoCallResponse>
  func send(error: MeetingDoctorsController.ErrorBodyModel, videoconsultation id: Swift.Int) -> RxSwift.Single<MeetingDoctorsSchema.ErrorSchema>
}
public protocol RepositoryControllerAssembly {
  func resolve() -> MeetingDoctorsController.RepositoryController?
}
public protocol DerivationReportAdapter {
  func fetch() -> RxSwift.Single<[MeetingDoctorsSchema.DerivationReportSchema]>
}
public class MDVideocallErrorModel : Swift.Codable {
  final public let code: Swift.Int?
  final public let message: Swift.String?
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public protocol ReferrerModelType : Swift.CustomStringConvertible {
  var source: Swift.String { get }
  var medium: Swift.String? { get }
  var campaign: Swift.String? { get }
  var content: Swift.String? { get }
  var term: Swift.String? { get }
  var data: [Swift.String : Swift.String] { get }
}
public struct ReferrerModel : MeetingDoctorsController.ReferrerModelType {
  public let source: Swift.String
  public let medium: Swift.String?
  public let campaign: Swift.String?
  public let content: Swift.String?
  public let term: Swift.String?
  public let data: [Swift.String : Swift.String]
  public init(source: Swift.String, medium: Swift.String?, campaign: Swift.String?, content: Swift.String?, term: Swift.String?, data: [Swift.String : Swift.String])
}
extension MeetingDoctorsController.ReferrerModel {
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case source
    case medium
    case campaign
    case content
    case term
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public init?(from campaign: Swift.String)
  public init?(with data: [Swift.String : Swift.String])
  public var description: Swift.String {
    get
  }
}
extension Foundation.Date {
  public var isInFuture: Swift.Bool {
    get
  }
}
extension MeetingDoctorsController.MessageDataModel : Swift.Equatable {
}
public func == (lhs: MeetingDoctorsController.MessageDataModel, rhs: MeetingDoctorsController.MessageDataModel) -> Swift.Bool
public struct AnySocketInputStream<EventType> : MeetingDoctorsController.SocketInputStream {
  public var name: Swift.String {
    get
  }
  public init<Concrete>(_ concrete: Concrete) where EventType == Concrete.EventType, Concrete : MeetingDoctorsController.SocketInputStream
  public func on() -> RxSwift.Observable<EventType>
}
public struct AnySocketOutputStream<EventType> : MeetingDoctorsController.SocketOutputStream {
  public var name: Swift.String {
    get
  }
  public init<Concrete>(_ concrete: Concrete) where EventType == Concrete.EventType, Concrete : MeetingDoctorsController.SocketOutputStream
  public func emit(event: EventType) throws
  public func acknowledge(event: EventType) throws -> RxSwift.Single<MeetingDoctorsSchema.SocketClientSchema.Input>
}
public struct AnySocketStream<NativeType, InputType, OutputType> : MeetingDoctorsController.SocketStream {
  public typealias SocketNativeType = NativeType
  public typealias SocketInputType = InputType
  public typealias SocketOutputType = OutputType
  public init<Concrete>(_ concrete: Concrete) where NativeType == Concrete.SocketNativeType, InputType == Concrete.SocketInputType, OutputType == Concrete.SocketOutputType, Concrete : MeetingDoctorsController.SocketStream
  public func connect<Credentials>(credentials: Credentials?) -> RxSwift.Observable<MeetingDoctorsController.AnySocketStream<NativeType, InputType, OutputType>.SocketNativeType> where Credentials : MeetingDoctorsSchema.SocketCredentials
  @discardableResult
  public func disconnect() -> RxSwift.Observable<MeetingDoctorsController.AnySocketStream<NativeType, InputType, OutputType>.SocketNativeType>
  public func input(stream event: MeetingDoctorsSchema.SocketListenerType) throws -> MeetingDoctorsController.AnySocketInputStream<MeetingDoctorsController.AnySocketStream<NativeType, InputType, OutputType>.SocketInputType>
  public func output(stream event: MeetingDoctorsSchema.SocketEmissionType) throws -> MeetingDoctorsController.AnySocketOutputStream<MeetingDoctorsController.AnySocketStream<NativeType, InputType, OutputType>.SocketOutputType>
  public func join(namespace: Swift.String)
  public func leave()
  public func clear()
  public var error: RxSwift.Observable<MeetingDoctorsController.AnySocketStream<NativeType, InputType, OutputType>.SocketNativeType> {
    get
  }
  public var status: RxSwift.Observable<MeetingDoctorsController.AnySocketStream<NativeType, InputType, OutputType>.SocketNativeType> {
    get
  }
}
public protocol MedicalSpecialityModelType {
  var id: Swift.String { get }
  var name: Swift.String { get }
  var coverageId: Swift.String? { get }
  var details: Swift.String? { get }
}
public struct MedicalSpecialityModel : MeetingDoctorsController.MedicalSpecialityModelType {
  public let id: Swift.String
  public let name: Swift.String
  public let coverageId: Swift.String?
  public let details: Swift.String?
  public init(id: Swift.String, name: Swift.String, coverageId: Swift.String?, details: Swift.String?)
}
extension MeetingDoctorsController.MedicalSpecialityModel : MeetingDoctorsController.AutoLenses {
}
extension MeetingDoctorsController.MedicalSpecialityModel : MeetingDoctorsCore.Transmittable {
  public typealias SchemaObject = MeetingDoctorsSchema.MedicalSpecialitySchema
  public var schemaObject: MeetingDoctorsSchema.MedicalSpecialitySchema {
    get
  }
  public init(schemaObject: MeetingDoctorsSchema.MedicalSpecialitySchema) throws
}
public protocol VideoCallModelProtocol {
  var id: Swift.Int { get }
  var workflow: Swift.String { get }
  var roomId: Swift.Int? { get }
  var professionalHash: Swift.String? { get }
}
public struct VideoCallModel : MeetingDoctorsController.VideoCallModelProtocol {
  public let id: Swift.Int
  public let workflow: Swift.String
  public let roomId: Swift.Int?
  public let professionalHash: Swift.String?
  public init(id: Swift.Int, workflow: Swift.String, roomId: Swift.Int?, professionalHash: Swift.String?)
  public var workflowType: MeetingDoctorsSchema.VideoCallWorkflow? {
    get
  }
}
extension MeetingDoctorsController.VideoCallModel {
  public init(schema: MeetingDoctorsSchema.VideoCallSchema)
}
extension MeetingDoctorsController.VideoCallModel : MeetingDoctorsController.AutoLenses {
}
extension MeetingDoctorsController.VideoCallModel : Swift.Equatable {
  public static func == (a: MeetingDoctorsController.VideoCallModel, b: MeetingDoctorsController.VideoCallModel) -> Swift.Bool
}
public enum KeychainAccessOption {
  case accessibleWhenUnlocked
  case accessibleWhenUnlockedThisDeviceOnly
  case accessibleAfterFirstUnlock
  case accessibleAfterFirstUnlockThisDeviceOnly
  case accessibleAlways
  case accessibleWhenPasscodeSetThisDeviceOnly
  case accessibleAlwaysThisDeviceOnly
  public var value: Swift.String {
    get
  }
  public static func == (a: MeetingDoctorsController.KeychainAccessOption, b: MeetingDoctorsController.KeychainAccessOption) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension MeetingDoctorsSchema.ScheduleSchema.WeekDay : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension MeetingDoctorsSchema.ScheduleSchema.WeekDay {
  public static let allValues: [MeetingDoctorsSchema.ScheduleSchema.WeekDay]
  public static let workDaysValues: [MeetingDoctorsSchema.ScheduleSchema.WeekDay]
}
public struct Changeset {
  public let deleted: [Swift.Int]
  public let inserted: [Swift.Int]
  public let updated: [Swift.Int]
  public init(deleted: [Swift.Int], inserted: [Swift.Int], updated: [Swift.Int], offset: Swift.Int = 0, limit: Swift.Int = 0)
}
public protocol DiseaseModelType {
  var id: Swift.String { get }
  var name: Swift.String { get }
  var details: Swift.String? { get }
  var diagnosis: Foundation.Date? { get }
  var resolution: Foundation.Date? { get }
  var patientHash: Swift.String { get }
}
public struct DiseaseModel : MeetingDoctorsController.DiseaseModelType {
  public static let Stub: MeetingDoctorsController.DiseaseModel
  public let id: Swift.String
  public let name: Swift.String
  public let details: Swift.String?
  public let diagnosis: Foundation.Date?
  public let resolution: Foundation.Date?
  public let patientHash: Swift.String
  public init(id: Swift.String, name: Swift.String, details: Swift.String?, diagnosis: Foundation.Date?, resolution: Foundation.Date?, patientHash: Swift.String)
}
extension MeetingDoctorsController.DiseaseModel : Swift.Equatable {
  public static func == (lhs: MeetingDoctorsController.DiseaseModel, rhs: MeetingDoctorsController.DiseaseModel) -> Swift.Bool
}
extension MeetingDoctorsController.DiseaseModel : MeetingDoctorsCore.Transmittable {
  public typealias SchemaObject = MeetingDoctorsSchema.DiseaseSchema
  public var schemaObject: MeetingDoctorsSchema.DiseaseSchema {
    get
  }
  public init(schemaObject: MeetingDoctorsSchema.DiseaseSchema) throws
}
extension MeetingDoctorsController.DiseaseModel : MeetingDoctorsController.AutoLenses {
}
public class MDVideocallParticipantRequestModel : Swift.Codable {
  final public let user: Swift.String?
  final public let name: Swift.String?
  final public let image: Swift.String?
  final public let role: Swift.String?
  public init(user: Swift.String?, name: Swift.String?, image: Swift.String? = nil, role: MeetingDoctorsController.MDVideocallParticipantType? = .participant)
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public protocol CustomerInstallationControllerProtocol {
  func fetch() -> RxSwift.Observable<MeetingDoctorsController.CustomerInstallationModel?>
  func update(pushToken: Swift.String?) -> RxSwift.Observable<MeetingDoctorsController.CustomerInstallationModel>
  func installation(in _: Foundation.Bundle, id _: Foundation.UUID) -> RxSwift.Observable<MeetingDoctorsController.CustomerInstallationModel>
  func fetch(completion: @escaping (Swift.Result<MeetingDoctorsController.CustomerInstallationModel?, Swift.Error>) -> Swift.Void)
  func update(pushToken: Swift.String?, completion: @escaping (Swift.Result<MeetingDoctorsController.CustomerInstallationModel?, Swift.Error>) -> Swift.Void)
  func installation(in _: Foundation.Bundle, id _: Foundation.UUID, completion: @escaping (Swift.Result<MeetingDoctorsController.CustomerInstallationModel?, Swift.Error>) -> Swift.Void)
}
public class CustomerInstallationController : MeetingDoctorsController.CustomerInstallationControllerProtocol {
  public init(keystore: MeetingDoctorsCore.Keystore, repository: MeetingDoctorsController.RepositoryController, remote: MeetingDoctorsController.RemoteController, scheduler: RxSwift.ImmediateSchedulerType)
  public func fetch() -> RxSwift.Observable<MeetingDoctorsController.CustomerInstallationModel?>
  public func update(pushToken: Swift.String?) -> RxSwift.Observable<MeetingDoctorsController.CustomerInstallationModel>
  public func installation(in bundle: Foundation.Bundle, id chatId: Foundation.UUID) -> RxSwift.Observable<MeetingDoctorsController.CustomerInstallationModel>
  public func fetch(completion: @escaping (Swift.Result<MeetingDoctorsController.CustomerInstallationModel?, Swift.Error>) -> Swift.Void)
  public func update(pushToken: Swift.String?, completion: @escaping (Swift.Result<MeetingDoctorsController.CustomerInstallationModel?, Swift.Error>) -> Swift.Void)
  public func installation(in bundle: Foundation.Bundle, id chatId: Foundation.UUID, completion: @escaping (Swift.Result<MeetingDoctorsController.CustomerInstallationModel?, Swift.Error>) -> Swift.Void)
  @objc deinit
}
extension Foundation.Date {
  public var isTomorrow: Swift.Bool {
    get
  }
}
public protocol EncryptionProvider {
  var key: Foundation.Data? { get }
}
extension MeetingDoctorsController.EncryptionProvider {
  public var key: Foundation.Data? {
    get
  }
}
public struct AnyMedicalHistoryDetailControllerType<ElementModel> : MeetingDoctorsController.MedicalHistoryDetailControllerType where ElementModel : MeetingDoctorsCore.Transmittable {
  public init<Concrete>(_ concrete: Concrete) where ElementModel == Concrete.ElementModel, Concrete : MeetingDoctorsController.MedicalHistoryDetailControllerType
  public func fetch(by id: Swift.String) -> RxSwift.Observable<ElementModel?>
  public func save(_ element: ElementModel, update: Swift.Bool) -> RxSwift.Observable<ElementModel>
  public func delete(_ element: ElementModel) -> RxSwift.Observable<Swift.Void>
}
extension RxSwift.PrimitiveSequence where Trait == RxSwift.SingleTrait {
  public func asMaybe() -> RxSwift.PrimitiveSequence<RxSwift.MaybeTrait, Element>
  public func asCompletable() -> RxSwift.PrimitiveSequence<RxSwift.CompletableTrait, Swift.Never>
}
extension RxSwift.PrimitiveSequence where Trait == RxSwift.CompletableTrait, Element == Swift.Never {
  public func asMaybe() -> RxSwift.PrimitiveSequence<RxSwift.MaybeTrait, Element>
}
public class MDVideocallResponseModel : Swift.Codable {
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
extension Foundation.Date {
  public var isInPast: Swift.Bool {
    get
  }
}
public protocol VideoCallProfessionalModelProtocol {
  var name: Swift.String? { get }
  var avatar: Swift.String? { get }
  var detail: Swift.String? { get }
}
public struct VideoCallProfessionalModel : MeetingDoctorsController.VideoCallProfessionalModelProtocol {
  public let name: Swift.String?
  public let avatar: Swift.String?
  public let detail: Swift.String?
  public init(name: Swift.String?, avatar: Swift.String?, detail: Swift.String?)
}
extension MeetingDoctorsController.VideoCallProfessionalModel {
  public init(schema: MeetingDoctorsSchema.VideoCallProfessionalSchema?)
}
extension MeetingDoctorsController.VideoCallProfessionalModel : MeetingDoctorsController.AutoLenses {
}
extension MeetingDoctorsController.VideoCallProfessionalModel : Swift.Equatable {
  public static func == (a: MeetingDoctorsController.VideoCallProfessionalModel, b: MeetingDoctorsController.VideoCallProfessionalModel) -> Swift.Bool
}
public protocol CustomerNotificationsAdapter {
  func register(_ request: MeetingDoctorsSchema.CustomerRegisterNotificationRequest) -> RxSwift.Single<MeetingDoctorsSchema.CustomerNotificationSchema>
  func unregister(_ request: MeetingDoctorsSchema.CustomerRegisterNotificationRequest) -> RxSwift.Single<MeetingDoctorsSchema.CustomerErrorSchema>
}
public protocol InboxControllerType {
  func fetch(user: MeetingDoctorsController.UserModel, filter: MeetingDoctorsController.InboxController.Filter) -> RxSwift.Observable<([MeetingDoctorsController.InboxContactModel], MeetingDoctorsController.Changeset?)>
  func refresh()
  func user(_ model: MeetingDoctorsController.UserModel) -> RxSwift.Observable<MeetingDoctorsController.UserModel?>
}
public class InboxController : MeetingDoctorsController.InboxControllerType {
  public struct Filter {
    public let roles: [MeetingDoctorsController.SpecialityTypeModel]
    public let status: [MeetingDoctorsController.ContactStatusModel]
    public let ids: [Swift.String]
    public let roomIds: [Swift.String]
    public let professionalHashes: [Swift.String]
    public let limit: Swift.Int
    public let excludeRoles: Swift.Bool
    public init(roles: [MeetingDoctorsController.SpecialityTypeModel], status: [MeetingDoctorsController.ContactStatusModel] = ContactStatusModel.allCases, ids: [Swift.String] = [], roomIds: [Swift.String] = [], professionalHashes: [Swift.String] = [], limit: Swift.Int = 0, excludeRoles: Swift.Bool = false)
  }
  public init(_ repository: MeetingDoctorsController.RepositoryController, _ socket: MeetingDoctorsController.AnySocketControllerStream, scheduler: RxSwift.ImmediateSchedulerType)
  public func fetch(user: MeetingDoctorsController.UserModel, filter: MeetingDoctorsController.InboxController.Filter) -> RxSwift.Observable<([MeetingDoctorsController.InboxContactModel], MeetingDoctorsController.Changeset?)>
  public func refresh()
  public func user(_ model: MeetingDoctorsController.UserModel) -> RxSwift.Observable<MeetingDoctorsController.UserModel?>
  @objc deinit
}
extension MeetingDoctorsController.InboxController.Filter {
  public var predicate: Foundation.NSPredicate {
    get
  }
}
public struct UserFeaturesModel {
  public let videoCall: Swift.Bool?
  public let videoCall1to1: Swift.Bool?
  public init(videoCall: Swift.Bool? = nil, videoCall1to1: Swift.Bool? = nil)
}
extension MeetingDoctorsController.UserFeaturesModel {
  public init(schema: MeetingDoctorsSchema.UserFeaturesSchema)
}
public class MDVideocallRequestModel : Swift.Codable {
  public init(id: Swift.String?, apiKey: Swift.String?, consultation: Swift.Int?, type: MeetingDoctorsController.MDVideocallType?, speciality: Swift.String?, participants: [MeetingDoctorsController.MDVideocallParticipantRequestModel]?, group: Swift.String?)
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public enum SystemModel : Swift.String {
  case iOS
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public typealias AnySocketControllerStream = MeetingDoctorsController.AnySocketStream<MeetingDoctorsController.SocketControllerModel, MeetingDoctorsSchema.SocketClientSchema.Input, MeetingDoctorsSchema.SocketClientSchema.Output>
public protocol SocketController : MeetingDoctorsController.SocketStream where Self.SocketInputType == MeetingDoctorsSchema.SocketClientSchema.Input, Self.SocketNativeType == MeetingDoctorsController.SocketControllerModel, Self.SocketOutputType == MeetingDoctorsSchema.SocketClientSchema.Output {
}
public protocol VideoCallUseCaseProtocol : AnyObject {
  func call(completion: @escaping (MeetingDoctorsController.VideoCallModel?) -> Swift.Void)
  func cancel(by id: Swift.Int, with completion: @escaping (MeetingDoctorsController.VideoCallModel?) -> Swift.Void)
  func pickUp(by id: Swift.Int, with completion: @escaping (MeetingDoctorsController.VideoCallModel) -> Swift.Void)
  func hangUp(by id: Swift.Int, with completion: @escaping (MeetingDoctorsController.VideoCallModel) -> Swift.Void)
}
public class VideoCallUseCase : MeetingDoctorsController.VideoCallUseCaseProtocol {
  public init(repository: MeetingDoctorsController.VideoCallRepositoryProtocol)
  public func call(completion: @escaping (MeetingDoctorsController.VideoCallModel?) -> Swift.Void)
  public func cancel(by id: Swift.Int, with completion: @escaping (MeetingDoctorsController.VideoCallModel?) -> Swift.Void)
  public func pickUp(by id: Swift.Int, with completion: @escaping (MeetingDoctorsController.VideoCallModel) -> Swift.Void)
  public func hangUp(by id: Swift.Int, with completion: @escaping (MeetingDoctorsController.VideoCallModel) -> Swift.Void)
  @objc deinit
}
public struct AnyMedicalHistoryAdapter<SchemaType> : MeetingDoctorsController.MedicalHistoryAdapter where SchemaType : MeetingDoctorsSchema.MedicalHistorySchema {
  public init<Concrete>(_ concrete: Concrete) where SchemaType == Concrete.SchemaType, Concrete : MeetingDoctorsController.MedicalHistoryAdapter
  public func fetch(by id: Swift.String) -> RxSwift.Single<SchemaType?>
  public func fetch() -> RxSwift.Single<[SchemaType]>
  public func save(entity: SchemaType, update: Swift.Bool) -> RxSwift.Single<SchemaType>
  public func delete(entity: SchemaType) -> RxSwift.Completable
}
public struct AnyIdentifiableAdapter<SchemaType> : MeetingDoctorsController.IdentifiableAdapter where SchemaType : MeetingDoctorsSchema.IdentifiableSchema {
  public init<Concrete>(_ concrete: Concrete) where SchemaType == Concrete.SchemaType, Concrete : MeetingDoctorsController.IdentifiableAdapter
  public func fetch(by id: Swift.String) -> RxSwift.Single<SchemaType?>
  public func fetch() -> RxSwift.Single<[SchemaType]>
  public func save(entity: SchemaType, update: Swift.Bool) -> RxSwift.Single<SchemaType>
  public func delete(entity: SchemaType) -> RxSwift.Completable
}
public struct AnyMedicalDirectoryAdapter<SchemaType> : MeetingDoctorsController.MedicalDirectoryAdapter where SchemaType : MeetingDoctorsSchema.MedicalDirectorySchema {
  public init<Concrete>(_ concrete: Concrete) where SchemaType == Concrete.SchemaType, Concrete : MeetingDoctorsController.MedicalDirectoryAdapter
  public func fetch<ParameterType>(_ request: ParameterType? = nil, type: ParameterType.Type = ParameterType.self, completion: @escaping (Swift.Result<[SchemaType], Swift.Error>) -> Swift.Void) where ParameterType : MeetingDoctorsSchema.PaginableRequest
}
public struct AnyRepository<E> : MeetingDoctorsController.Repository {
  public init<Base>(_ base: Base) where E == Base.EntityType, Base : MeetingDoctorsController.Repository
  public func fetch(by id: Swift.String) -> RxSwift.Observable<E?>
  public func fetch() -> RxSwift.Observable<([E], MeetingDoctorsController.Changeset?)>
  public func query(with predicate: Foundation.NSPredicate, sorted descriptors: [Foundation.NSSortDescriptor] = [], offset: Swift.Int = 0, limit: Swift.Int = 0) -> RxSwift.Observable<([E], MeetingDoctorsController.Changeset?)>
  public func save(entity: E, update: Swift.Bool = true) -> RxSwift.Observable<Swift.Void>
  public func save<S>(collection: S, update: Swift.Bool, clear: Swift.Bool) -> RxSwift.Observable<Swift.Void> where E == S.Element, S : Swift.Sequence
  public func update(properties: [MeetingDoctorsController.AttributeValueType]) -> RxSwift.Observable<Swift.Void>
  public func delete(entity: E) -> RxSwift.Observable<Swift.Void>
  public func delete<S>(collection: S) -> RxSwift.Observable<Swift.Void> where E == S.Element, S : Swift.Sequence
  public func delete(with predicate: Foundation.NSPredicate) -> RxSwift.Observable<Swift.Void>
  public func clear(cascading: Swift.Bool = true) -> RxSwift.Observable<Swift.Void>
  public func fetch(by id: Swift.String, completion: @escaping (Swift.Result<E?, Swift.Error>) -> Swift.Void)
  public func fetch(completion: @escaping (Swift.Result<[E], Swift.Error>) -> Swift.Void)
  public func query(with predicate: Foundation.NSPredicate, sorted descriptors: [Foundation.NSSortDescriptor] = [], offset: Swift.Int = 0, limit: Swift.Int = 0, completion: @escaping (Swift.Result<[E], Swift.Error>) -> Swift.Void)
  public func save(entity: E, update: Swift.Bool = true, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func save<S>(collection: S, update: Swift.Bool, clear: Swift.Bool, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) where E == S.Element, S : Swift.Sequence
  public func update(properties: [MeetingDoctorsController.AttributeValueType], completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func delete(entity: E, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func delete<S>(collection: S, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) where E == S.Element, S : Swift.Sequence
  public func delete(with predicate: Foundation.NSPredicate, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func clear(cascading: Swift.Bool, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public typealias EntityType = E
}
public enum SocketControllerModel {
  case connect(Swift.String)
  case disconnect(Swift.String)
  case status(MeetingDoctorsController.ConnectionStatusModel)
  case error(Swift.Error)
  case reconnect
  case reconnectAttempt
}
extension MeetingDoctorsController.SocketControllerModel {
  public var status: MeetingDoctorsController.ConnectionStatusModel? {
    get
  }
}
public enum SpecialityTypeModel : Swift.String, Swift.CaseIterable {
  case unknown
  case generalMedicine
  case pediatrics
  case psychology
  case sportsMedicine
  case customerCare
  case medicalSupport
  case personalTraining
  case commercial
  case medicalAppointment
  case cardiology
  case gynecology
  case pharmacy
  case sexology
  case nutrition
  case fertilityConsultant
  case nursing
  case medicalAdvisor
  case dermatology
  case customerCareIsaludColectivos
  case veterinary
  case ethology
  case doctorGoHealthAdvisor
  case fitnessCoaching
  case nutritionalCoaching
  case animalNutrition
  case medicalManager
  case coachMental
  public static var all: [MeetingDoctorsController.SpecialityTypeModel] {
    get
  }
  public static var none: [MeetingDoctorsController.SpecialityTypeModel] {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [MeetingDoctorsController.SpecialityTypeModel]
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension MeetingDoctorsController.SpecialityTypeModel {
  public var id: Swift.String {
    get
  }
}
extension Swift.Int {
  public var nanoseconds: Foundation.DateComponents {
    get
  }
  public var seconds: Foundation.DateComponents {
    get
  }
  public var minutes: Foundation.DateComponents {
    get
  }
  public var hours: Foundation.DateComponents {
    get
  }
  public var days: Foundation.DateComponents {
    get
  }
  public var weeks: Foundation.DateComponents {
    get
  }
  public var months: Foundation.DateComponents {
    get
  }
  public var years: Foundation.DateComponents {
    get
  }
}
extension Foundation.Date {
  public struct Options {
    public var allowedComponents: Swift.Set<Foundation.Calendar.Component>
    public var imminentRange: Foundation.DateComponents?
    public var distantRange: Foundation.DateComponents?
  }
  public func colloquialSinceNow(options fOptions: Foundation.Date.Options? = nil) -> Swift.String
  public func colloquial(to date: Foundation.Date, options fOptions: Foundation.Date.Options? = nil) -> Swift.String
  public static func colloquial(from fDate: Foundation.Date, to tDate: Foundation.Date, options fOptions: Foundation.Date.Options? = nil) -> Swift.String
  public var year: Swift.Int {
    get
  }
  public var month: Swift.Int {
    get
  }
  public var day: Swift.Int {
    get
  }
  public var weekday: Swift.String {
    get
  }
  public func add(components: Foundation.DateComponents) -> Foundation.Date?
}
extension Foundation.DateComponents {
  public func `in`(_ component: Foundation.Calendar.Component) -> Swift.Int?
}
public struct AnyMedicalDirectoryListControllerType<ElementModel> : MeetingDoctorsController.MedicalDirectoryListControllerType where ElementModel : MeetingDoctorsCore.Transmittable {
  public init<Concrete>(_ concrete: Concrete) where ElementModel == Concrete.ElementModel, Concrete : MeetingDoctorsController.MedicalDirectoryListControllerType
  public func fetch(query: MeetingDoctorsController.MedicalQueryBuilder, completion: @escaping (Swift.Result<[ElementModel], Swift.Error>) -> Swift.Void)
  public func get(query: MeetingDoctorsController.MedicalQueryBuilder, completion: @escaping (Swift.Result<[ElementModel], Swift.Error>) -> Swift.Void)
}
final public class RunLoopThreadScheduler : RxSwift.ImmediateSchedulerType {
  public init(thread: MeetingDoctorsController.RunLoopThread)
  final public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> RxSwift.Disposable) -> RxSwift.Disposable
  @objc deinit
}
@objc final public class RunLoopThread : Foundation.Thread {
  final public var runLoop: Foundation.RunLoop!
  public init(name: Swift.String)
  @objc override final public func main()
  @objc deinit
}
public protocol MedicalProfessionalModelType {
  var id: Swift.String { get }
  var name: Swift.String { get }
  var phone: Swift.String { get }
  var address: Swift.String { get }
  var zip: Swift.String { get }
  var coordinates: CoreLocation.CLLocationCoordinate2D? { get }
  var coverages: [Swift.String]? { get }
  var specialities: [Swift.String]? { get }
}
public struct MedicalProfessionalModel : MeetingDoctorsController.MedicalProfessionalModelType {
  public enum Kind : Swift.String {
    case unknown
    case professional
    case center
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let id: Swift.String
  public let name: Swift.String
  public let type: MeetingDoctorsController.MedicalProfessionalModel.Kind
  public let phone: Swift.String
  public let address: Swift.String
  public let zip: Swift.String
  public let coordinates: CoreLocation.CLLocationCoordinate2D?
  public let coverages: [Swift.String]?
  public let specialities: [Swift.String]?
  public init(id: Swift.String, name: Swift.String, type: MeetingDoctorsController.MedicalProfessionalModel.Kind, phone: Swift.String, address: Swift.String, zip: Swift.String)
  public init(id: Swift.String, name: Swift.String, type: MeetingDoctorsController.MedicalProfessionalModel.Kind, phone: Swift.String, address: Swift.String, zip: Swift.String, coordinates: CoreLocation.CLLocationCoordinate2D?, coverages: [Swift.String]?, specialities: [Swift.String]?)
}
extension MeetingDoctorsController.MedicalProfessionalModel {
  public var location: CoreLocation.CLLocation? {
    get
  }
  public func distance(from location: CoreLocation.CLLocation) -> CoreLocation.CLLocationDistance
}
extension MeetingDoctorsController.MedicalProfessionalModel : MeetingDoctorsCore.Transmittable {
  public typealias SchemaObject = MeetingDoctorsSchema.MedicalProfessionalSchema
  public var schemaObject: MeetingDoctorsSchema.MedicalProfessionalSchema {
    get
  }
  public init(schemaObject: MeetingDoctorsSchema.MedicalProfessionalSchema) throws
}
extension MeetingDoctorsController.MedicalProfessionalModel.Kind : MeetingDoctorsCore.Transmittable {
  public typealias SchemaObject = MeetingDoctorsSchema.MedicalProfessionalSchema.Kind
  public var schemaObject: MeetingDoctorsSchema.MedicalProfessionalSchema.Kind {
    get
  }
  public init(schemaObject: MeetingDoctorsSchema.MedicalProfessionalSchema.Kind) throws
}
public protocol AuthenticationAdapter {
  func authenticate(_ request: MeetingDoctorsSchema.AuthenticateRequest) -> RxSwift.Single<MeetingDoctorsSchema.SessionSchema>
  func user(_ request: MeetingDoctorsSchema.UserRequest) -> RxSwift.Single<MeetingDoctorsSchema.UserSchema>
  func authenticate(_ request: MeetingDoctorsSchema.AuthenticateRequest, completion: @escaping (Swift.Result<MeetingDoctorsSchema.SessionSchema, Swift.Error>) -> Swift.Void)
  func user(_ request: MeetingDoctorsSchema.UserRequest, completion: @escaping (Swift.Result<MeetingDoctorsSchema.UserSchema, Swift.Error>) -> Swift.Void)
}
public protocol AutoCases {
}
public enum ScheduleStateModel : Swift.String {
  case unknown
  case disabled
  case enabled
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ScheduleAvailabilityModel : Swift.Int, Swift.CustomStringConvertible {
  case unknown
  case holidays
  case now
  case soon
  case tomorrow
  case forthcoming
  public func next() -> MeetingDoctorsController.ScheduleAvailabilityModel
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol CustomerUserModelProtocol {
  var hash: Swift.String { get }
  var token: Swift.String { get }
}
public struct CustomerUserModel : Swift.Codable, MeetingDoctorsController.CustomerUserModelProtocol {
  public let hash: Swift.String
  public let token: Swift.String
  public init(hash: Swift.String, token: Swift.String)
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension MeetingDoctorsController.CustomerUserModel {
  public init(schema: MeetingDoctorsSchema.CustomerUserSchema)
}
extension MeetingDoctorsController.CustomerUserModel : Swift.Equatable {
  public static func == (a: MeetingDoctorsController.CustomerUserModel, b: MeetingDoctorsController.CustomerUserModel) -> Swift.Bool
}
public typealias AttributeValue = (name: Swift.String, value: Any)
public protocol AttributeValueType {
  var parameter: MeetingDoctorsController.AttributeValue { get }
}
public protocol QueryType {
  var predicate: Foundation.NSPredicate? { get }
  var descriptors: [Foundation.NSSortDescriptor] { get }
  var offset: Swift.Int { get }
  var limit: Swift.Int { get }
}
public enum MDVCParticipantProviderResponseEnum : Swift.String, Swift.Codable {
  case opentok
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum MDVCParticipantArgumentResponseEnum : Swift.String, Swift.Codable, Swift.Equatable {
  case moderatorUserDisconected
  case moderatorWPDisconected
  case moderatorIssuesAudio
  case moderatorIssuesVideo
  case moderatorIssuesBlocked
  case moderatorUserBehaviour
  case moderatorOther
  case moderatorReportAdded
  case moderatorRejectedVideocall
  case userLongWaiting
  case userTestError
  case userBadConnection
  case userIssueTechnical
  case userNotNeededAnymore
  case userOther
  case userTimeoutWaiting
  case userCreatedNewVideocall
  case connectionIssues
  case empty
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public class MDVideocallParticipantResponseModel : Swift.Codable {
  final public let id: Swift.String?
  final public let videocall: Swift.String?
  final public let apiKey: Swift.String?
  final public let type: MeetingDoctorsController.MDVideocallType?
  final public let provider: MeetingDoctorsController.MDVCParticipantProviderResponseEnum?
  final public let status: MeetingDoctorsController.MDVideocallStatusType?
  final public let argument: MeetingDoctorsController.MDVCParticipantArgumentResponseEnum?
  final public let consultation: Swift.String?
  final public let speciality: Swift.String?
  final public let session: Swift.String?
  final public let token: Swift.String?
  final public let user: Swift.String?
  final public let name: Swift.String?
  final public let image: Swift.String?
  final public let role: MeetingDoctorsController.MDVideocallParticipantType?
  final public let position: Swift.Int?
  final public let time: Swift.Int?
  final public let createdAt: Swift.String?
  final public let updatedAt: Swift.String?
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public protocol InstallationAdapter {
  func setup(_ request: MeetingDoctorsSchema.SetupRequest) -> RxSwift.Single<MeetingDoctorsSchema.SetupSchema>
  func setup(_ request: MeetingDoctorsSchema.SetupRequest, completion: @escaping (Swift.Result<MeetingDoctorsSchema.SetupSchema?, Swift.Error>) -> Swift.Void)
}
@_inheritsConvenienceInitializers public class ImageLoader : MeetingDoctorsCore.Loader<Foundation.URL, RxSwift.Single<UIKit.UIImage>> {
  convenience override public init()
  public init(loaders: [Swift.String : MeetingDoctorsCore.Loader<Foundation.URL, RxSwift.Single<UIKit.UIImage>>])
  override public func load(_ source: Foundation.URL) -> RxSwift.Single<UIKit.UIImage>?
  public subscript(scheme: Swift.String) -> MeetingDoctorsCore.Loader<Foundation.URL, RxSwift.Single<UIKit.UIImage>>? {
    get
    set
  }
  @objc deinit
}
public class MDVideocallParticipantStatusRequestModel : Swift.Codable {
  public init(status: MeetingDoctorsController.MDVideocallStatusType?, signIn: Swift.Bool? = nil, argument: Swift.String? = "-")
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public protocol MessageModelType : Swift.CustomStringConvertible {
  var id: Swift.String { get }
  var room: Swift.String { get }
  var sender: Swift.String { get }
  var metadata: MeetingDoctorsController.MessageDataModel { get }
  var kind: MeetingDoctorsController.MessageTypeModel { get }
  var status: MeetingDoctorsController.MessageStatusModel { get }
  var timestamp: Foundation.TimeInterval { get }
}
public struct MessageModel : MeetingDoctorsController.MessageModelType {
  public let id: Swift.String
  public let room: Swift.String
  public let sender: Swift.String
  public let metadata: MeetingDoctorsController.MessageDataModel
  public let status: MeetingDoctorsController.MessageStatusModel
  public let timestamp: Foundation.TimeInterval
  public var kind: MeetingDoctorsController.MessageTypeModel {
    get
  }
  public var description: Swift.String {
    get
  }
  public init(id: Foundation.UUID, room: Swift.Int, sender: MeetingDoctorsController.UserModel, metadata: MeetingDoctorsController.MessageDataModel, date: Foundation.Date = Date())
  public init(id: Swift.String, room: Swift.String, sender: Swift.String, metadata: MeetingDoctorsController.MessageDataModel, status: MeetingDoctorsController.MessageStatusModel, timestamp: Foundation.TimeInterval)
}
extension MeetingDoctorsController.MessageModel : MeetingDoctorsController.AutoLenses {
}
public protocol NotificationControllerType {
  func authorize(_ application: UIKit.UIApplication)
  @available(iOS 10.0, *)
  func authorize(_ application: UIKit.UIApplication, notification center: UserNotifications.UNUserNotificationCenter)
  func unreadMessageCount(for user: MeetingDoctorsController.UserModel) -> RxSwift.Single<Swift.Int>
}
public class NotificationController : MeetingDoctorsController.NotificationControllerType {
  public init(_ installation: MeetingDoctorsController.InstallationController, remote: MeetingDoctorsController.RemoteController)
  public func authorize(_ application: UIKit.UIApplication)
  @available(iOS 10.0, *)
  public func authorize(_ application: UIKit.UIApplication, notification center: UserNotifications.UNUserNotificationCenter)
  public func unreadMessageCount(for user: MeetingDoctorsController.UserModel) -> RxSwift.Single<Swift.Int>
  @objc deinit
}
public protocol InboxContactModelType {
  var id: Swift.String { get }
  var channel: Swift.String { get }
  var name: Swift.String { get }
  var avatarURL: Foundation.URL { get }
  var overview: Swift.String { get }
  var speciality: Swift.String { get }
  var specialityCode: Swift.String { get }
  var specialityType: MeetingDoctorsController.SpecialityTypeModel { get }
  var role: MeetingDoctorsController.ContactRoleModel { get }
  var status: MeetingDoctorsController.ContactStatusModel { get set }
  var unread: [MeetingDoctorsController.MessageModel] { get }
  var lastMessageTimestamp: Foundation.TimeInterval? { get }
  var pending: Swift.Int { get }
  var timezone: Foundation.TimeZone { get }
  var onHolidays: Swift.Bool { get }
  var schedules: [MeetingDoctorsController.ScheduleModel] { get }
  var saturated: Swift.String { get }
  var collegiateNumber: Swift.String { get }
  var conversationId: Swift.String? { get }
  var isAccessible: Swift.Bool { get }
}
public struct InboxContactModel : MeetingDoctorsController.InboxContactModelType {
  public let id: Swift.String
  public let channel: Swift.String
  public let name: Swift.String
  public let avatarURL: Foundation.URL
  public let overview: Swift.String
  public let speciality: Swift.String
  public let specialityCode: Swift.String
  public let specialityType: MeetingDoctorsController.SpecialityTypeModel
  public let role: MeetingDoctorsController.ContactRoleModel
  public var status: MeetingDoctorsController.ContactStatusModel
  public let unread: [MeetingDoctorsController.MessageModel]
  public let lastMessageTimestamp: Foundation.TimeInterval?
  public let pending: Swift.Int
  public let timezone: Foundation.TimeZone
  public let timeZoneOffset: Swift.Int
  public let nextOnlineAt: Foundation.Date?
  public let nextOfflineAt: Foundation.Date?
  public let onHolidays: Swift.Bool
  public let schedules: [MeetingDoctorsController.ScheduleModel]
  public let updatedAt: Foundation.Date
  public let saturated: Swift.String
  public let collegiateNumber: Swift.String
  public let conversationId: Swift.String?
  public let isVcAvailable: Swift.Bool?
  public let isAccessible: Swift.Bool
  public init(id: Swift.String, channel: Swift.String, name: Swift.String, avatarURL: Foundation.URL, overview: Swift.String, speciality: Swift.String, specialityCode: Swift.String, specialityType: MeetingDoctorsController.SpecialityTypeModel, role: MeetingDoctorsController.ContactRoleModel, status: MeetingDoctorsController.ContactStatusModel, unread: [MeetingDoctorsController.MessageModel], lastMessageTimestamp: Foundation.TimeInterval?, pending: Swift.Int, timezone: Foundation.TimeZone, timeZoneOffset: Swift.Int, nextOnlineAt: Foundation.Date?, nextOfflineAt: Foundation.Date?, onHolidays: Swift.Bool, schedules: [MeetingDoctorsController.ScheduleModel], updatedAt: Foundation.Date, saturated: Swift.String, collegiateNumber: Swift.String, conversationId: Swift.String?, isVcAvailable: Swift.Bool?, isAccessible: Swift.Bool)
}
extension MeetingDoctorsController.InboxContactModel {
  public typealias ScheduleAvailability = (schedule: Foundation.Date?, availability: MeetingDoctorsController.ScheduleAvailabilityModel)
  public func findNextSchedule() -> (schedule: Foundation.Date?, availability: MeetingDoctorsController.ScheduleAvailabilityModel)
  public func mapWeekDaySchedule(for date: Foundation.Date) -> [MeetingDoctorsSchema.ScheduleSchema.WeekDay : [Foundation.DateInterval?]]
}
extension MeetingDoctorsController.InboxContactModel {
  public var lastMessageDate: Foundation.Date? {
    get
  }
}
extension MeetingDoctorsController.InboxContactModel : MeetingDoctorsController.AutoLenses {
}
public protocol Repository {
  associatedtype EntityType
  func fetch(by id: Swift.String) -> RxSwift.Observable<Self.EntityType?>
  func fetch() -> RxSwift.Observable<([Self.EntityType], MeetingDoctorsController.Changeset?)>
  func query(with predicate: Foundation.NSPredicate, sorted descriptors: [Foundation.NSSortDescriptor], offset: Swift.Int, limit: Swift.Int) -> RxSwift.Observable<([Self.EntityType], MeetingDoctorsController.Changeset?)>
  func save(entity: Self.EntityType, update: Swift.Bool) -> RxSwift.Observable<Swift.Void>
  func save<S>(collection: S, update: Swift.Bool, clear: Swift.Bool) -> RxSwift.Observable<Swift.Void> where S : Swift.Sequence, Self.EntityType == S.Element
  func update(properties: [MeetingDoctorsController.AttributeValueType]) -> RxSwift.Observable<Swift.Void>
  func delete(entity: Self.EntityType) -> RxSwift.Observable<Swift.Void>
  func delete<S>(collection: S) -> RxSwift.Observable<Swift.Void> where S : Swift.Sequence, Self.EntityType == S.Element
  func delete(with predicate: Foundation.NSPredicate) -> RxSwift.Observable<Swift.Void>
  func clear(cascading: Swift.Bool) -> RxSwift.Observable<Swift.Void>
  func fetch(by id: Swift.String, completion: @escaping (Swift.Result<Self.EntityType?, Swift.Error>) -> Swift.Void)
  func fetch(completion: @escaping (Swift.Result<[Self.EntityType], Swift.Error>) -> Swift.Void)
  func query(with predicate: Foundation.NSPredicate, sorted descriptors: [Foundation.NSSortDescriptor], offset: Swift.Int, limit: Swift.Int, completion: @escaping (Swift.Result<[Self.EntityType], Swift.Error>) -> Swift.Void)
  func save(entity: Self.EntityType, update: Swift.Bool, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  func save<S>(collection: S, update: Swift.Bool, clear: Swift.Bool, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) where S : Swift.Sequence, Self.EntityType == S.Element
  func update(properties: [MeetingDoctorsController.AttributeValueType], completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  func delete(entity: Self.EntityType, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  func delete<S>(collection: S, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) where S : Swift.Sequence, Self.EntityType == S.Element
  func delete(with predicate: Foundation.NSPredicate, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  func clear(cascading: Swift.Bool, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
}
extension MeetingDoctorsController.Repository {
  public func fetch(by _: Swift.String) -> RxSwift.Observable<Self.EntityType?>
  public func fetch() -> RxSwift.Observable<([Self.EntityType], MeetingDoctorsController.Changeset?)>
  public func query(with _: Foundation.NSPredicate, sorted _: [Foundation.NSSortDescriptor] = [], offset: Swift.Int = 0, limit: Swift.Int = 0) -> RxSwift.Observable<([Self.EntityType], MeetingDoctorsController.Changeset?)>
  public func save(entity _: Self.EntityType, update _: Swift.Bool = true) -> RxSwift.Observable<Swift.Void>
  public func save<S>(collection _: S, update _: Swift.Bool, clear _: Swift.Bool) -> RxSwift.Observable<Swift.Void> where S : Swift.Sequence, Self.EntityType == S.Element
  public func update(properties _: [MeetingDoctorsController.AttributeValueType]) -> RxSwift.Observable<Swift.Void>
  public func delete(entity _: Self.EntityType) -> RxSwift.Observable<Swift.Void>
  public func delete<S>(collection _: S) -> RxSwift.Observable<Swift.Void> where S : Swift.Sequence, Self.EntityType == S.Element
  public func clear(cascading _: Swift.Bool = true) -> RxSwift.Observable<Swift.Void>
  public func fetch(by _: Swift.String, completion _: @escaping (Swift.Result<Self.EntityType?, Swift.Error>) -> Swift.Void)
  public func fetch(completion _: @escaping (Swift.Result<[Self.EntityType], Swift.Error>) -> Swift.Void)
  public func query(with _: Foundation.NSPredicate, sorted _: [Foundation.NSSortDescriptor], offset _: Swift.Int, limit _: Swift.Int, completion _: @escaping (Swift.Result<[Self.EntityType], Swift.Error>) -> Swift.Void)
  public func save(entity _: Self.EntityType, update _: Swift.Bool, completion _: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func save<S>(collection _: S, update _: Swift.Bool, clear _: Swift.Bool, completion _: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) where S : Swift.Sequence, Self.EntityType == S.Element
  public func update(properties _: [MeetingDoctorsController.AttributeValueType], completion _: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func delete(entity _: Self.EntityType, completion _: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func delete<S>(collection _: S, completion _: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) where S : Swift.Sequence, Self.EntityType == S.Element
  public func delete(with _: Foundation.NSPredicate, completion _: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func clear(cascading _: Swift.Bool, completion _: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
}
public enum RepositoryError : Swift.Error {
  public enum StoreFailureReason {
    case nilConfigurationFileURL
    case providerFailed(error: Swift.Error)
    case writeOperationFailed(error: Swift.Error)
    case collectionObserverFailed(error: Swift.Error)
    case objectObserverFailed(error: Swift.Error)
    case objectDeleted
    case storeNotInitialized
  }
  case storeFailed(reason: MeetingDoctorsController.RepositoryError.StoreFailureReason)
}
extension MeetingDoctorsController.RepositoryError {
  public var underlyingError: Swift.Error? {
    get
  }
}
public class MDVideoconsultationStatusRequestModel : Swift.Codable {
  public init(status: Swift.String?)
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public protocol MedicalDirectoryAdapter {
  associatedtype SchemaType : MeetingDoctorsSchema.MedicalDirectorySchema
  func fetch<ParameterType>(_ request: ParameterType?, type: ParameterType.Type, completion: @escaping (Swift.Result<[Self.SchemaType], Swift.Error>) -> Swift.Void) where ParameterType : MeetingDoctorsSchema.PaginableRequest
}
public struct AnyMedicalHistoryListControllerType<ElementModel> : MeetingDoctorsController.MedicalHistoryListControllerType where ElementModel : MeetingDoctorsCore.Transmittable {
  public init<Concrete>(_ concrete: Concrete) where ElementModel == Concrete.ElementModel, Concrete : MeetingDoctorsController.MedicalHistoryListControllerType
  public func fetch(patient hash: Swift.String) -> RxSwift.Observable<([ElementModel], MeetingDoctorsController.Changeset?)>
}
@objc @_inheritsConvenienceInitializers final public class LocationModel : CoreLocation.CLLocation {
  convenience public init(_ location: CoreLocation.CLLocation)
  @objc override dynamic public init(latitude: CoreLocation.CLLocationDegrees, longitude: CoreLocation.CLLocationDegrees)
  @objc override dynamic public init(coordinate: CoreLocation.CLLocationCoordinate2D, altitude: CoreLocation.CLLocationDistance, horizontalAccuracy hAccuracy: CoreLocation.CLLocationAccuracy, verticalAccuracy vAccuracy: CoreLocation.CLLocationAccuracy, timestamp: Foundation.Date)
  @available(iOS 4.2, *)
  @objc override dynamic public init(coordinate: CoreLocation.CLLocationCoordinate2D, altitude: CoreLocation.CLLocationDistance, horizontalAccuracy hAccuracy: CoreLocation.CLLocationAccuracy, verticalAccuracy vAccuracy: CoreLocation.CLLocationAccuracy, course: CoreLocation.CLLocationDirection, speed: CoreLocation.CLLocationSpeed, timestamp: Foundation.Date)
  @available(iOS 13.4, *)
  @objc override dynamic public init(coordinate: CoreLocation.CLLocationCoordinate2D, altitude: CoreLocation.CLLocationDistance, horizontalAccuracy hAccuracy: CoreLocation.CLLocationAccuracy, verticalAccuracy vAccuracy: CoreLocation.CLLocationAccuracy, course: CoreLocation.CLLocationDirection, courseAccuracy: CoreLocation.CLLocationDirectionAccuracy, speed: CoreLocation.CLLocationSpeed, speedAccuracy: CoreLocation.CLLocationSpeedAccuracy, timestamp: Foundation.Date)
  @available(iOS 15.0, *)
  @objc override dynamic public init(coordinate: CoreLocation.CLLocationCoordinate2D, altitude: CoreLocation.CLLocationDistance, horizontalAccuracy hAccuracy: CoreLocation.CLLocationAccuracy, verticalAccuracy vAccuracy: CoreLocation.CLLocationAccuracy, course: CoreLocation.CLLocationDirection, courseAccuracy: CoreLocation.CLLocationDirectionAccuracy, speed: CoreLocation.CLLocationSpeed, speedAccuracy: CoreLocation.CLLocationSpeedAccuracy, timestamp: Foundation.Date, sourceInfo: CoreLocation.CLLocationSourceInformation)
  @objc override dynamic public init()
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public protocol SocketOutputStream : MeetingDoctorsSchema.SocketEventType {
  associatedtype EventType
  func emit(event: Self.EventType) throws
  func acknowledge(event: Self.EventType) throws -> RxSwift.Single<MeetingDoctorsSchema.SocketClientSchema.Input>
}
public protocol SocketInputStream : MeetingDoctorsSchema.SocketEventType {
  associatedtype EventType
  func on() -> RxSwift.Observable<Self.EventType>
}
public protocol SocketStream {
  associatedtype SocketNativeType
  associatedtype SocketInputType
  associatedtype SocketOutputType
  var error: RxSwift.Observable<Self.SocketNativeType> { get }
  var status: RxSwift.Observable<Self.SocketNativeType> { get }
  func connect<Credentials>(credentials: Credentials?) -> RxSwift.Observable<Self.SocketNativeType> where Credentials : MeetingDoctorsSchema.SocketCredentials
  func disconnect() -> RxSwift.Observable<Self.SocketNativeType>
  func input(stream event: MeetingDoctorsSchema.SocketListenerType) throws -> MeetingDoctorsController.AnySocketInputStream<Self.SocketInputType>
  func output(stream event: MeetingDoctorsSchema.SocketEmissionType) throws -> MeetingDoctorsController.AnySocketOutputStream<Self.SocketOutputType>
  func join(namespace: Swift.String)
  func leave()
  func clear()
}
public protocol IMCModelType {
  var id: Swift.String { get }
  var weight: Swift.Int? { get }
  var height: Swift.Int? { get }
  var value: Swift.Float? { get }
  var patientHash: Swift.String { get }
  var updatedAt: Foundation.Date? { get }
  var createdAt: Foundation.Date? { get }
}
public struct IMCModel : MeetingDoctorsController.IMCModelType {
  public static let Stub: MeetingDoctorsController.IMCModel
  public let id: Swift.String
  public let weight: Swift.Int?
  public let height: Swift.Int?
  public let value: Swift.Float?
  public let patientHash: Swift.String
  public let updatedAt: Foundation.Date?
  public let createdAt: Foundation.Date?
  public init(id: Swift.String, weight: Swift.Int?, height: Swift.Int?, value: Swift.Float?, patientHash: Swift.String, updatedAt: Foundation.Date?, createdAt: Foundation.Date?)
}
extension MeetingDoctorsController.IMCModel : Swift.Equatable {
  public static func == (lhs: MeetingDoctorsController.IMCModel, rhs: MeetingDoctorsController.IMCModel) -> Swift.Bool
}
extension MeetingDoctorsController.IMCModel : MeetingDoctorsCore.Transmittable {
  public typealias SchemaObject = MeetingDoctorsSchema.IMCSchema
  public var schemaObject: MeetingDoctorsSchema.IMCSchema {
    get
  }
  public init(schemaObject: MeetingDoctorsSchema.IMCSchema) throws
}
extension MeetingDoctorsController.IMCModel : MeetingDoctorsController.AutoLenses {
}
extension Swift.PartialKeyPath where Root == MeetingDoctorsController.IMCModel {
  public var stringValue: Swift.String {
    get
  }
}
public enum UserGenderModel : Swift.String {
  case unknown
  case male
  case female
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension MeetingDoctorsSchema.UserSchema.Gender {
  public var model: MeetingDoctorsController.UserGenderModel {
    get
  }
}
public enum MessageStatusModel : Swift.String {
  case pending
  case sent
  case delivered
  case received
  case read
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension MeetingDoctorsSchema.MessageSchema.Status {
  public init(model: MeetingDoctorsController.MessageStatusModel)
}
public class MDVideocallCommonDataResponse<ResponseModel> : Swift.Codable where ResponseModel : Swift.Decodable, ResponseModel : Swift.Encodable {
  final public let id: Swift.String?
  final public let type: Swift.String?
  final public let attributes: ResponseModel
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public enum ScheduleWeekDayModel : Swift.String {
  case unknown
  case sunday
  case monday
  case tuesday
  case wednesday
  case thursday
  case friday
  case saturday
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc public class DerivationsListController : ObjectiveC.NSObject {
  public init(_ account: MeetingDoctorsController.AccountModel, repository: MeetingDoctorsController.RepositoryController, remote: MeetingDoctorsController.RemoteController, scheduler: RxSwift.ImmediateSchedulerType, auth: MeetingDoctorsController.CustomerAuthControllerProtocol)
  public func fetch(patient hash: Swift.String) -> RxSwift.Observable<([MeetingDoctorsController.DerivationReportModel], MeetingDoctorsController.Changeset?)>
  public func refresh() -> RxSwift.Observable<([MeetingDoctorsController.DerivationReportModel], MeetingDoctorsController.Changeset?)>
  @objc deinit
}
public protocol AllergyModelType {
  var id: Swift.String { get }
  var name: Swift.String { get }
  var severity: Swift.Int { get }
  var details: Swift.String { get }
  var patientHash: Swift.String { get }
}
public struct AllergyModel : MeetingDoctorsController.AllergyModelType {
  public static let Stub: MeetingDoctorsController.AllergyModel
  public let id: Swift.String
  public let name: Swift.String
  public let severity: Swift.Int
  public let details: Swift.String
  public let patientHash: Swift.String
  public init(id: Swift.String, name: Swift.String, severity: Swift.Int, details: Swift.String, patientHash: Swift.String)
}
extension MeetingDoctorsController.AllergyModel : Swift.Equatable {
  public static func == (lhs: MeetingDoctorsController.AllergyModel, rhs: MeetingDoctorsController.AllergyModel) -> Swift.Bool
}
extension MeetingDoctorsController.AllergyModel : MeetingDoctorsCore.Transmittable {
  public typealias SchemaObject = MeetingDoctorsSchema.AllergySchema
  public var schemaObject: MeetingDoctorsSchema.AllergySchema {
    get
  }
  public init(schemaObject: MeetingDoctorsSchema.AllergySchema) throws
}
extension MeetingDoctorsController.AllergyModel : MeetingDoctorsController.AutoLenses {
}
extension Swift.PartialKeyPath where Root == MeetingDoctorsController.AllergyModel {
  public var stringValue: Swift.String {
    get
  }
}
public protocol MedicalAddressModelType {
  var address: Swift.String? { get }
  var location: CoreLocation.CLLocationCoordinate2D? { get }
}
public struct MedicalAddressModel : MeetingDoctorsController.MedicalAddressModelType {
  public let address: Swift.String?
  public let location: CoreLocation.CLLocationCoordinate2D?
  public init(address: Swift.String?, location: CoreLocation.CLLocationCoordinate2D?)
}
extension MeetingDoctorsController.MedicalAddressModel : MeetingDoctorsCore.Transmittable {
  public typealias SchemaObject = MeetingDoctorsSchema.MedicalAddressSchema
  public var schemaObject: MeetingDoctorsSchema.MedicalAddressSchema {
    get
  }
  public init(schemaObject: MeetingDoctorsSchema.MedicalAddressSchema) throws
}
public class MDVideocallDoctorAvailableModel {
  final public let professionalId: Swift.String?
  final public let name: Swift.String?
  final public let specialty: Swift.String?
  final public let imageURL: Swift.String?
  public init(professionalId: Swift.String?, name: Swift.String?, specialty: Swift.String?, imageURL: Swift.String?)
  @objc deinit
}
public enum MDVideocallType : Swift.String, Swift.Codable, Swift.Equatable {
  case pool
  case oneToOne
  public func callAsFunction() -> Swift.String
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol ScheduleModelType {
  var id: Swift.String { get }
  var userId: Swift.String { get }
  var state: MeetingDoctorsController.ScheduleStateModel { get }
  var weekDay: MeetingDoctorsController.ScheduleWeekDayModel { get }
  var firstPeriodStart: Swift.Int { get }
  var firstPeriodEnd: Swift.Int { get }
  var secondPeriodStart: Swift.Int { get }
  var secondPeriodEnd: Swift.Int { get }
}
public struct ScheduleModel : MeetingDoctorsController.ScheduleModelType {
  public let id: Swift.String
  public let userId: Swift.String
  public let state: MeetingDoctorsController.ScheduleStateModel
  public let weekDay: MeetingDoctorsController.ScheduleWeekDayModel
  public let firstPeriodStart: Swift.Int
  public let firstPeriodEnd: Swift.Int
  public let secondPeriodStart: Swift.Int
  public let secondPeriodEnd: Swift.Int
  public init(id: Swift.String, userId: Swift.String, state: MeetingDoctorsController.ScheduleStateModel, weekDay: MeetingDoctorsController.ScheduleWeekDayModel, firstPeriodStart: Swift.Int, firstPeriodEnd: Swift.Int, secondPeriodStart: Swift.Int, secondPeriodEnd: Swift.Int)
}
extension MeetingDoctorsController.ScheduleModel {
  public var firstPeriodTimeInterval: Foundation.TimeInterval {
    get
  }
  public var secondPeriodTimeInterval: Foundation.TimeInterval {
    get
  }
  public var dayOfWeek: MeetingDoctorsSchema.ScheduleSchema.WeekDay? {
    get
  }
  public func firstPeriodDateTimeInterval(_ date: Foundation.Date) -> Foundation.DateInterval?
  public func secondPeriodDateTimeInterval(_ date: Foundation.Date) -> Foundation.DateInterval?
}
public protocol AccountModelType : Swift.Encodable {
  var id: Swift.String { get }
  var token: Swift.String { get }
  var installation: MeetingDoctorsController.InstallationModel { get }
}
public struct AccountModel : MeetingDoctorsController.AccountModelType {
  public let id: Swift.String
  public let token: Swift.String
  public var user: MeetingDoctorsController.UserModel
  public let installation: MeetingDoctorsController.InstallationModel
  public init(id: Swift.String, token: Swift.String, user: MeetingDoctorsController.UserModel, installation: MeetingDoctorsController.InstallationModel)
}
extension MeetingDoctorsController.AccountModel : MeetingDoctorsSchema.ChatSocketCredentials {
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case clientSecret
    case sessionId
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public var clientId: Swift.String {
    get
  }
  public var clientSecret: Swift.String {
    get
  }
  public var sessionId: Swift.String {
    get
  }
  public func encode(to encoder: Swift.Encoder) throws
}
extension MeetingDoctorsController.AccountModel : MeetingDoctorsController.AutoLenses {
}
public enum ContactStatusModel : Swift.String {
  case unknown
  case offline
  case online
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension MeetingDoctorsController.ContactStatusModel {
  public static let count: Swift.Int
  public static let allCases: [MeetingDoctorsController.ContactStatusModel]
}
public protocol ConversationModelType {
  var id: Swift.String { get }
  var messages: [MeetingDoctorsController.MessageModel] { get }
  var lastMessageTimestamp: Foundation.TimeInterval? { get }
}
public struct ConversationModel : MeetingDoctorsController.ConversationModelType {
  public let id: Swift.String
  public let messages: [MeetingDoctorsController.MessageModel]
  public let lastMessageTimestamp: Foundation.TimeInterval?
  public init(id: Swift.String, messages: [MeetingDoctorsController.MessageModel], lastMessageTimestamp: Foundation.TimeInterval?)
}
public struct MedicalHistoryActiveAndOptionsModel {
  public let active: Swift.Bool
  public let medicalHistory: [MeetingDoctorsController.MedicalHistoryModel]
  public init(active: Swift.Bool, medicalHistory: [MeetingDoctorsController.MedicalHistoryModel])
}
@_hasMissingDesignatedInitializers public class MedicalHistoryActiveAndOptionConverter {
  @objc deinit
}
public protocol MedicationModelType {
  var id: Swift.String { get }
  var name: Swift.String { get }
  var posology: Swift.String? { get }
  var details: Swift.String? { get }
  var patientHash: Swift.String { get }
}
public struct MedicationModel : MeetingDoctorsController.MedicationModelType {
  public static let Stub: MeetingDoctorsController.MedicationModel
  public let id: Swift.String
  public let name: Swift.String
  public let posology: Swift.String?
  public let details: Swift.String?
  public let patientHash: Swift.String
  public init(id: Swift.String, name: Swift.String, posology: Swift.String?, details: Swift.String?, patientHash: Swift.String)
}
extension MeetingDoctorsController.MedicationModel : Swift.Equatable {
  public static func == (lhs: MeetingDoctorsController.MedicationModel, rhs: MeetingDoctorsController.MedicationModel) -> Swift.Bool
}
extension MeetingDoctorsController.MedicationModel : MeetingDoctorsCore.Transmittable {
  public typealias SchemaObject = MeetingDoctorsSchema.MedicationSchema
  public var schemaObject: MeetingDoctorsSchema.MedicationSchema {
    get
  }
  public init(schemaObject: MeetingDoctorsSchema.MedicationSchema) throws
}
extension MeetingDoctorsController.MedicationModel : MeetingDoctorsController.AutoLenses {
}
public struct EnvironmentVariables {
  public struct Inbox {
    public static let RetrieveAll: MeetingDoctorsCore.NamedProperty<Swift.Bool>
  }
  public struct Security {
    public static let Log: MeetingDoctorsCore.NamedProperty<Swift.Bool>
  }
}
@_hasMissingDesignatedInitializers public class ProfessionalsRepository {
  public static func setIsProfessional()
  public static func setIsUser()
  public static func getIsProfessional() -> Swift.Bool
  @objc deinit
}
public protocol CustomerInstallationModelProtocol {
  var id: Swift.String { get }
  var installationGuid: Swift.String { get }
  var pushToken: Swift.String? { get }
}
public struct CustomerInstallationModel : MeetingDoctorsController.CustomerInstallationModelProtocol {
  public let id: Swift.String
  public let installationGuid: Swift.String
  public var pushToken: Swift.String?
  public init(id: Swift.String, installationGuid: Swift.String, pushToken: Swift.String?)
}
extension MeetingDoctorsController.CustomerInstallationModel {
  public init(id: Swift.String, schema: MeetingDoctorsSchema.CustomerInstallationSchema)
}
extension MeetingDoctorsController.CustomerInstallationModel : MeetingDoctorsController.AutoLenses {
}
extension MeetingDoctorsController.CustomerInstallationModel : Swift.Equatable {
  public static func == (a: MeetingDoctorsController.CustomerInstallationModel, b: MeetingDoctorsController.CustomerInstallationModel) -> Swift.Bool
}
public struct CompanyReportModel {
  public let id: Swift.Int?
  public let name: Swift.String?
  public let logo: Swift.String?
  public init(id: Swift.Int?, name: Swift.String?, logo: Swift.String?)
}
public protocol VideoCallUserModelType {
  var hash: Swift.String { get }
  var name: Swift.String? { get }
  var avatar: Swift.String? { get }
  var description: Swift.String? { get }
}
public struct VideoCallUserModel : MeetingDoctorsController.VideoCallUserModelType {
  public static let Stub: MeetingDoctorsController.VideoCallUserModel
  public let hash: Swift.String
  public let name: Swift.String?
  public let avatar: Swift.String?
  public let description: Swift.String?
  public init(hash: Swift.String, name: Swift.String?, avatar: Swift.String?, description: Swift.String?)
}
extension MeetingDoctorsController.VideoCallUserModel : MeetingDoctorsCore.Transmittable {
  public typealias SchemaObject = MeetingDoctorsSchema.VideoCallUserSchema
  public var schemaObject: MeetingDoctorsSchema.VideoCallUserSchema {
    get
  }
  public init(schemaObject: MeetingDoctorsSchema.VideoCallUserSchema) throws
}
extension MeetingDoctorsController.VideoCallUserModel : Swift.Equatable {
  public static func == (lhs: MeetingDoctorsController.VideoCallUserModel, rhs: MeetingDoctorsController.VideoCallUserModel) -> Swift.Bool
}
extension MeetingDoctorsController.VideoCallUserModel : MeetingDoctorsController.AutoLenses {
}
public protocol VideoCallAdapter {
  func call() -> RxSwift.Single<MeetingDoctorsSchema.VideoCallResponse>
  func cancel(by id: Swift.Int) -> RxSwift.Single<MeetingDoctorsSchema.VideoCallResponse>
  func pickUp(by id: Swift.Int) -> RxSwift.Single<MeetingDoctorsSchema.VideoCallResponse>
  func hangUp(by id: Swift.Int) -> RxSwift.Single<MeetingDoctorsSchema.VideoCallResponse>
  func videoCallStatus() -> RxSwift.Single<MeetingDoctorsSchema.VideoCallStatusResponse>
}
public protocol MedicalCoverageModelType {
  var id: Swift.String { get }
  var name: Swift.String { get }
}
public struct MedicalCoverageModel : MeetingDoctorsController.MedicalCoverageModelType {
  public let id: Swift.String
  public let name: Swift.String
  public init(id: Swift.String, name: Swift.String)
}
extension MeetingDoctorsController.MedicalCoverageModel : MeetingDoctorsCore.Transmittable {
  public typealias SchemaObject = MeetingDoctorsSchema.MedicalCoverageSchema
  public var schemaObject: MeetingDoctorsSchema.MedicalCoverageSchema {
    get
  }
  public init(schemaObject: MeetingDoctorsSchema.MedicalCoverageSchema) throws
}
public protocol UserModelType {
  var id: Swift.String { get }
  var firstName: Swift.String? { get }
  var lastName: Swift.String? { get }
  var email: Swift.String? { get }
  var phone: Swift.String? { get }
  var documentId: Swift.String? { get }
  var gender: MeetingDoctorsController.UserGenderModel? { get }
  var status: MeetingDoctorsController.UserRegistrationStatusModel? { get }
  var birthday: Foundation.Date? { get }
  var cardNumber: Swift.String? { get }
  var contract: Swift.String? { get }
  var coverage: Swift.String? { get }
  var company: Swift.String? { get }
  var isBanned: Swift.Bool { get }
  var termsAcceptedAt: Foundation.Date? { get set }
  var companyGroupCode: Swift.String? { get }
  func hasAccess(to contact: MeetingDoctorsController.InboxContactModel) -> Swift.Bool
}
public struct UserModel : MeetingDoctorsController.UserModelType {
  public let id: Swift.String
  public let firstName: Swift.String?
  public let lastName: Swift.String?
  public let email: Swift.String?
  public let phone: Swift.String?
  public let documentId: Swift.String?
  public let gender: MeetingDoctorsController.UserGenderModel?
  public let status: MeetingDoctorsController.UserRegistrationStatusModel?
  public let birthday: Foundation.Date?
  public let cardNumber: Swift.String?
  public let contract: Swift.String?
  public let coverage: Swift.String?
  public let company: Swift.String?
  public let isBanned: Swift.Bool
  public let features: MeetingDoctorsController.UserFeaturesModel?
  public var termsAcceptedAt: Foundation.Date?
  public let companyGroupCode: Swift.String?
  public var displayName: Swift.String {
    get
  }
  public var isClient: Swift.Bool {
    get
  }
  public init(id: Swift.String, firstName: Swift.String?, lastName: Swift.String?, email: Swift.String?, phone: Swift.String?, documentId: Swift.String?, gender: MeetingDoctorsController.UserGenderModel?, status: MeetingDoctorsController.UserRegistrationStatusModel?, birthday: Foundation.Date?, cardNumber: Swift.String?, contract: Swift.String?, coverage: Swift.String?, company: Swift.String?, isBanned: Swift.Bool, features: MeetingDoctorsController.UserFeaturesModel?, termsAcceptedAt: Foundation.Date?, companyGroupCode: Swift.String?)
  public func hasAccess(to contact: MeetingDoctorsController.InboxContactModel) -> Swift.Bool
}
extension MeetingDoctorsController.UserModel {
  public init(id: Swift.String, schema: MeetingDoctorsSchema.UserSchema)
}
public protocol CustomerInstallationAdapter {
  func installation(_ request: MeetingDoctorsSchema.CustomerInstallationRequest) -> RxSwift.Single<MeetingDoctorsSchema.CustomerInstallationSchema>
  func installation(_ request: MeetingDoctorsSchema.CustomerInstallationRequest, completion: @escaping (Swift.Result<MeetingDoctorsSchema.CustomerInstallationSchema, Swift.Error>) -> Swift.Void)
}
public protocol RemoteController {
  var installation: MeetingDoctorsController.InstallationAdapter { get }
  var customerInstallation: MeetingDoctorsController.CustomerInstallationAdapter { get }
  var customerAuth: MeetingDoctorsController.CustomerAuthAdapter { get }
  var customerNotifications: MeetingDoctorsController.CustomerNotificationsAdapter { get }
  var videoCall: MeetingDoctorsController.VideoCallAdapter { get }
  var authentication: MeetingDoctorsController.AuthenticationAdapter { get }
  var notification: MeetingDoctorsController.NotificationAdapter { get }
  var allergy: MeetingDoctorsController.AnyMedicalHistoryAdapter<MeetingDoctorsSchema.AllergySchema> { get }
  var disease: MeetingDoctorsController.AnyMedicalHistoryAdapter<MeetingDoctorsSchema.DiseaseSchema> { get }
  var medication: MeetingDoctorsController.AnyMedicalHistoryAdapter<MeetingDoctorsSchema.MedicationSchema> { get }
  var imc: MeetingDoctorsController.AnyIdentifiableAdapter<MeetingDoctorsSchema.IMCSchema> { get }
  var coverage: MeetingDoctorsController.AnyMedicalDirectoryAdapter<MeetingDoctorsSchema.MedicalCoverageSchema> { get }
  var speciality: MeetingDoctorsController.AnyMedicalDirectoryAdapter<MeetingDoctorsSchema.MedicalSpecialitySchema> { get }
  var professional: MeetingDoctorsController.AnyMedicalDirectoryAdapter<MeetingDoctorsSchema.MedicalProfessionalSchema> { get }
  var address: MeetingDoctorsController.AnyMedicalDirectoryAdapter<MeetingDoctorsSchema.MedicalAddressSchema> { get }
  var videoCallReport: MeetingDoctorsController.AnyMedicalHistoryAdapter<MeetingDoctorsSchema.VideoCallReportSchema> { get }
  var derivation: MeetingDoctorsController.DerivationReportAdapter { get }
  var videoCall1to1: MeetingDoctorsController.VideoCall1to1Adapter { get }
  var professionalList: MeetingDoctorsController.ProfessionalListAdapter { get }
  func join(account: MeetingDoctorsController.AccountModel)
  func joinCustomer(auth: MeetingDoctorsController.CustomerAuthModel)
  func joinProfessional(by token: Swift.String)
}
public protocol VideoCallReportModelType {
  var id: Swift.Int { get }
  var pdfUrl: Swift.String? { get }
  var owner: MeetingDoctorsController.VideoCallUserModel? { get }
  var maker: MeetingDoctorsController.VideoCallUserModel? { get }
  var createdAt: Foundation.Date? { get }
  var updatedAt: Foundation.Date? { get }
}
public struct VideoCallReportModel : MeetingDoctorsController.VideoCallReportModelType {
  public let id: Swift.Int
  public let pdfUrl: Swift.String?
  public let owner: MeetingDoctorsController.VideoCallUserModel?
  public let maker: MeetingDoctorsController.VideoCallUserModel?
  public let createdAt: Foundation.Date?
  public let updatedAt: Foundation.Date?
  public init(id: Swift.Int, pdfUrl: Swift.String?, owner: MeetingDoctorsController.VideoCallUserModel?, maker: MeetingDoctorsController.VideoCallUserModel?, createdAt: Foundation.Date?, updatedAt: Foundation.Date?)
}
extension MeetingDoctorsController.VideoCallReportModel : Swift.Equatable {
  public static func == (lhs: MeetingDoctorsController.VideoCallReportModel, rhs: MeetingDoctorsController.VideoCallReportModel) -> Swift.Bool
}
extension MeetingDoctorsController.VideoCallReportModel : MeetingDoctorsCore.Transmittable {
  public typealias SchemaObject = MeetingDoctorsSchema.VideoCallReportSchema
  public var schemaObject: MeetingDoctorsSchema.VideoCallReportSchema {
    get
  }
  public init(schemaObject: MeetingDoctorsSchema.VideoCallReportSchema) throws
}
extension MeetingDoctorsController.VideoCallReportModel : MeetingDoctorsController.AutoLenses {
}
extension MeetingDoctorsController.SpecialityTypeModel : Swift.Equatable {}
extension MeetingDoctorsController.SpecialityTypeModel : Swift.Hashable {}
extension MeetingDoctorsController.SpecialityTypeModel : Swift.RawRepresentable {}
extension MeetingDoctorsController.MDVideocallStatusType : Swift.Hashable {}
extension MeetingDoctorsController.MDVideocallStatusType : Swift.RawRepresentable {}
extension MeetingDoctorsController.MessageTypeModel : Swift.Equatable {}
extension MeetingDoctorsController.MessageTypeModel : Swift.Hashable {}
extension MeetingDoctorsController.MessageTypeModel : Swift.RawRepresentable {}
extension MeetingDoctorsController.UserRegistrationStatusModel : Swift.Equatable {}
extension MeetingDoctorsController.UserRegistrationStatusModel : Swift.Hashable {}
extension MeetingDoctorsController.UserRegistrationStatusModel : Swift.RawRepresentable {}
extension MeetingDoctorsController.MedicalQueryBuilder.Kind : Swift.Equatable {}
extension MeetingDoctorsController.MedicalQueryBuilder.Kind : Swift.Hashable {}
extension MeetingDoctorsController.ControllerError.InstallationFailureReason : Swift.Equatable {}
extension MeetingDoctorsController.ControllerError.InstallationFailureReason : Swift.Hashable {}
extension MeetingDoctorsController.ControllerError.TransmittableFailureReason : Swift.Equatable {}
extension MeetingDoctorsController.ControllerError.TransmittableFailureReason : Swift.Hashable {}
extension MeetingDoctorsController.MDVideocallParticipantType : Swift.Equatable {}
extension MeetingDoctorsController.MDVideocallParticipantType : Swift.Hashable {}
extension MeetingDoctorsController.MDVideocallParticipantType : Swift.RawRepresentable {}
extension MeetingDoctorsController.ContactRoleModel : Swift.Equatable {}
extension MeetingDoctorsController.ContactRoleModel : Swift.Hashable {}
extension MeetingDoctorsController.ContactRoleModel : Swift.RawRepresentable {}
extension MeetingDoctorsController.ConnectionStatusModel : Swift.Equatable {}
extension MeetingDoctorsController.ConnectionStatusModel : Swift.Hashable {}
extension MeetingDoctorsController.ConnectionStatusModel : Swift.RawRepresentable {}
extension MeetingDoctorsController.DerivationType : Swift.Equatable {}
extension MeetingDoctorsController.DerivationType : Swift.Hashable {}
extension MeetingDoctorsController.DerivationType : Swift.RawRepresentable {}
extension MeetingDoctorsController.ReferrerModel.CodingKeys : Swift.Equatable {}
extension MeetingDoctorsController.ReferrerModel.CodingKeys : Swift.Hashable {}
extension MeetingDoctorsController.ReferrerModel.CodingKeys : Swift.RawRepresentable {}
extension MeetingDoctorsController.KeychainAccessOption : Swift.Equatable {}
extension MeetingDoctorsController.KeychainAccessOption : Swift.Hashable {}
extension MeetingDoctorsController.SystemModel : Swift.Equatable {}
extension MeetingDoctorsController.SystemModel : Swift.Hashable {}
extension MeetingDoctorsController.SystemModel : Swift.RawRepresentable {}
extension MeetingDoctorsController.MedicalProfessionalModel.Kind : Swift.Equatable {}
extension MeetingDoctorsController.MedicalProfessionalModel.Kind : Swift.Hashable {}
extension MeetingDoctorsController.MedicalProfessionalModel.Kind : Swift.RawRepresentable {}
extension MeetingDoctorsController.ScheduleStateModel : Swift.Equatable {}
extension MeetingDoctorsController.ScheduleStateModel : Swift.Hashable {}
extension MeetingDoctorsController.ScheduleStateModel : Swift.RawRepresentable {}
extension MeetingDoctorsController.ScheduleAvailabilityModel : Swift.Equatable {}
extension MeetingDoctorsController.ScheduleAvailabilityModel : Swift.Hashable {}
extension MeetingDoctorsController.ScheduleAvailabilityModel : Swift.RawRepresentable {}
extension MeetingDoctorsController.MDVCParticipantProviderResponseEnum : Swift.Equatable {}
extension MeetingDoctorsController.MDVCParticipantProviderResponseEnum : Swift.Hashable {}
extension MeetingDoctorsController.MDVCParticipantProviderResponseEnum : Swift.RawRepresentable {}
extension MeetingDoctorsController.MDVCParticipantArgumentResponseEnum : Swift.Hashable {}
extension MeetingDoctorsController.MDVCParticipantArgumentResponseEnum : Swift.RawRepresentable {}
extension MeetingDoctorsController.UserGenderModel : Swift.Equatable {}
extension MeetingDoctorsController.UserGenderModel : Swift.Hashable {}
extension MeetingDoctorsController.UserGenderModel : Swift.RawRepresentable {}
extension MeetingDoctorsController.MessageStatusModel : Swift.Equatable {}
extension MeetingDoctorsController.MessageStatusModel : Swift.Hashable {}
extension MeetingDoctorsController.MessageStatusModel : Swift.RawRepresentable {}
extension MeetingDoctorsController.ScheduleWeekDayModel : Swift.Equatable {}
extension MeetingDoctorsController.ScheduleWeekDayModel : Swift.Hashable {}
extension MeetingDoctorsController.ScheduleWeekDayModel : Swift.RawRepresentable {}
extension MeetingDoctorsController.MDVideocallType : Swift.Hashable {}
extension MeetingDoctorsController.MDVideocallType : Swift.RawRepresentable {}
extension MeetingDoctorsController.AccountModel.CodingKeys : Swift.Equatable {}
extension MeetingDoctorsController.AccountModel.CodingKeys : Swift.Hashable {}
extension MeetingDoctorsController.AccountModel.CodingKeys : Swift.RawRepresentable {}
extension MeetingDoctorsController.ContactStatusModel : Swift.Equatable {}
extension MeetingDoctorsController.ContactStatusModel : Swift.Hashable {}
extension MeetingDoctorsController.ContactStatusModel : Swift.RawRepresentable {}
